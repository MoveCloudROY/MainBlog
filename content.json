{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Segment Tree(ZKW)(PART TWO)","text":"本来想看看网上的讲解的，结果发现都讲得不清楚，还是自己写一个吧 普通线段树与ZKW线段树 普通线段树通过递归建树，因而其常数相对较大 普通线段树代码长，相对较复杂 ZKW线段树通过循环建树，相对常数小 ZKW线段树代码短，易理解 ZKW线段树 · 无差分弱化版线段树是一种堆式储存结构， 观察其节点编号 将其转化成二进制 规律是很显然的 一个节点的父节点是这个数左移1，这个位运算就是低位舍弃，所有数字左移一位 一个节点的子节点是这个数右移1，是左节点，右移1 +1是右节点 同一层的节点是依次递增的，第$n$层有$2^{n-1}$个节点 最后一层有多少节点，值域就是多少(这个很重要) 有了这些规律就可以开始着手建树了 若树的层数为 $m$ ，则最后一层的节点数 $cnt$ 满足 $cnt = 2^{m-1}$ 若数的个数为 $x$ ，则数的个数x满足 $\\frac {cnt}{2} &lt; x &lt;= cnt$ （大于$x$小于$cnt$的部分无视） 底层节点序号从 $cnt$ 开始，一直到 $cnt+n-1$ 结束，第 $p$ 个数编号为 $cnt+p-1$ 所以我们需要先算出这个 $cnt$ 的最小值 1for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1);//这里没有等号，以保证cnt最小 建树12345678910int n,a[10005];struct node{ int num;}Tree[10005];inline void build(int n){ for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read();} 这仅仅是对叶子节点进行操作，之后，我们要依次更新父节点 由于是自下往上更新，所以，我们应当从 $cnt-1$ 开始，一直到 $1$ 12for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num; 最后的建树代码 123456inline void build(int n){ for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read(); for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num;} 单点操作直接修改 12345inline void change(int x,int k){ Tree[cnt+x-1].num+=k; while(x) Tree[x&gt;&gt;=1].num=Tree[x&lt;&lt;1].num+Tree[x&lt;&lt;1|1].num;//更新} 单点查询直接修改 1234inline int askpot(int pos){ return Tree[cnt+pos-1];} ZKW线段树 · 差分版建树我们发现，上面的方法对于区间操作时间复杂度会很高，因此，我们可以使用差分思想来进行优化 此时，线段树节点存的值是他和父节点的差值 我们再来写一下差分版的build 1234567891011void build(int n){ for (cnt = 1; cnt &lt; x; cnt &lt;&lt;= 1); for (int i = cnt; i &lt; cnt + n; i++) Tree[i].num = read(); for (int i = cnt - 1; i &gt;= 1; i--) { Tree[i].num = min(Tree[i &lt;&lt; 1].num, Tree[i &lt;&lt; 1 | 1]); Tree[i &lt;&lt; 1].num -= Tree[i]; Tree[i &lt;&lt; 1 | 1].num -= Tree[i]; }} 单点查询由于差分的性质 只需依次向上累加就可以求出改点的值 123456inline int askpot(int pos){ int sum=0,x=cnt+pos-1; while(x) sum+=Tree[x].num,x&gt;&gt;=1; return sum;} 区间查询 1inline int askRange(int l,int r)","link":"/posts/30408/"},{"title":"CycleGAN","text":"https://blog.csdn.net/gdymind/article/details/82696481","link":"/posts/10000/"},{"title":"Balance Tree(FHQ Treap)","text":"听说这个平衡树很~~好写~~，所以我尝试去学一下这个~~毒瘤~~的数据结构 FHQ Treap简介FHQ Treap只有两种主要的操作 * 分离（split） 把一棵树分成两个树 * 合并（merge） 把两棵树合成一棵树 通过 分离 和 合并 的操作，FHQ Treap可以完成普通平衡树的很多操作 插入 删除 查询排名为 $i$ 的数 查询 $wei$ 的排名 求 $wei$ 的前驱 求 $wei$ 的后继 反转区间 树的节点FHQ Treap 的节点维护的 普通Treap 维护的大致相同，我们通过一个结构体来保存信息 相关含义如下： size —&gt; 子树（包括自身）的大小 val —&gt; 该节点的值 rnd —&gt; Treap中用于堆的随机值 l r —&gt; 左节点和右节点 下面给出代码： 1234struct FHQ{ int size,val,rnd;}tr[N]; 操作 1 : 插入按照普通treap的写法，我们需要新建一个节点，需要调用newnode函数 123456int tot=0;int newnode(int v){ tr[++tot].size=1;tr[tot].val=v,tr[tot].rnd=rand(); return tot;//返回新节点的编号} 我们可以把原来的数按新节点的值分成两份，再依次合并，就完成了插入的过程 123456789void ins(int wei){ int x,y; spilt(root,wei,x,y); //root表示目前总树的根节点 //把总树分成以x,y为根节点的两棵树 root=merge(merge(x,newnode(wei)),y); //合并所有子树并重置根节点} 操作 2 ： 删除删除权值为 $wei$ 的点，先把整颗树以 $wei$ 为权值 $split$ 成两棵树 $x$，$y$，再把 $x$ 树按照 $wei-1$ 分成 $p$，$q$。 这时候值为wei的点一定为 $q$ 的根，那么我们把 $q$ 的两个子儿子 $merge$ 起来（这一步就是去除掉 $wei$ 的影响），再把他们重新 $merge$ 起来得到一个新的树，这颗树就去除掉了 $wei$ 的影响。 12345678void del(int wei){ int x,int y,int p,int q; spilt(root,wei,x,y); split(x,wei-1,p,q); q=merge(tr[q].l,tr[q].r); root=merge(merge(p,q),y);} 操作 3 ： 查询排名为 i 的数和普通Treap是一样的， 但注意，这个函数返回的是 排名为 i 的数 的节点编号k（值为tr[k].val） 。 12345678910111213141516int getNum(int now,int rk){ while(1) { if(rk&lt;=tr[tr[now].l].size) now=tr[now].l; else { if(rk==tr[tr[now].l].size+1) return now; else { rk-=tr[re[now].l].size+1; now=tr[now].r; } } }} 操作 4 ： 查询 wei 的排名把总树按 $wei$ 进行 $spilt$ ，得到左部分树的大小即为rank值。 123456int getRank(int wei){ int x,y; spilt(root,wei,x,y); return tr[x].size;} 操作 5 ： 求 wei 的前驱把总树按 $wei-1$ 分成两份， 所以小于 $wei$ 的节点都在左部分树中，只需要求出左部分树的size所对应的节点的值， 就是所求的 $wei$ 的前驱。 1234567int pre(int wei){ int x,y; spilt(root,wei-1,x,y); return tr[getNum(x,tr[x].size)].val; root=merge(x,y);//回复原状} 操作 6 ： 求 wei 的后继找后继是相同的，把总树按 $wei$ 为权值调用 $split$，此时右部分树排名第一的数就是后继 1234567int suc(int wei){ int x,y; spilt(root,wei+1,x,y); return tr[getNum(y,1)].val; root=merge(x,y);//回复原状} 操作 7 ： 反转区间~~先咕着，有空补~~ 核心 1： merge 操作$merge$ 操作即按照 FHQ Treap 的附加权值~~玄学~~维持平衡并进行合并 1234567891011121314151617int merge(int x,int y)//x 恒&lt; y ,所以需要保证顺序{ if(!x||!y) return x+y; update(x),update(y); if(tr[x].rnd&lt;tr[y].rnd) { tr[x].r=merge(tr[x].r,y); update(x); return x; } else { tr[y].l=merge(x,tr[y].l); update(y); return y; }} 核心 2： spilt 操作$split$ 是把一颗Treap分开两个树的操作。 有两种分法，一种是按权值分，一种是按$size$（子树大小）分，具体用哪个要看情况。 按权值分 注意这时候权值小于等于 k的节点都在左树中，大于 k的都在右树中 ： 12345678910111213void spilt(int now,int val,int &amp;x,int &amp;y){ if(!now) x=y=0; else { if(val&lt;=tr[tr[now].l].val) y=now,spilt(tr[now].l,val,x,tr[now].l); else x=now,spilt(tr[now].r,val,tr[now].r,y); update(now); } } 按 $size$ 分 ： 12345678910111213void spilt(int now,int rnk,int &amp;x,int &amp;y){ if(!now) x=y=0; else { if(rnk&lt;=tr[tr[now].l].size) y=now,spilt(tr[now].l,rnk,x,tr[now].l); else x=now,spilt(tr[now].r,rnk-tr[tr[now].l].size-1,tr[now].r,y); update(now); } } END","link":"/posts/31323/"},{"title":"Segment Tree (PART ONE)","text":"概念 线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为$O(logn)$。 操作下面我们从一个经典的例子来了解线段树 12从数组arr[0...n-1]中查找某个数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新。 我们可以用线段树来解决这个问题：预处理耗时$O(n)$，查询、更新操作$O(logn)$，需要额外的空间$O(n)$。根据这个问题我们构造如下的二叉树 - 叶子节点是原始组数arr中的元素 - 非叶子节点代表它的所有子孙叶子节点所在区间的最小值 例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）： 由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含$n$个叶子节点的完全二叉树，它一定有$n-1$个非叶节点，总共$2n-1$个节点，因此存储线段是需要的空间复杂度是$O(n)$ 创建线段树子节点根据线段树的性质（完全二叉树），只需知道父节点，就可以计算出子节点的序号 12345678inline LL getLeftNum(LL p){ return p&lt;&lt;1;}inline LL getRightNum(LL p){ return p&lt;&lt;1|1;} 树的存放和节点信息首先，我们需要判断我们需要维护的对象，可以是一个值，也可以是颜色，状态等 1234struct{ int val;//可以添加col,status，lztag}Tree[N]; 建树操作我们使用递归操作来建树 当左端点和右段点相同时，意味着此时的$p$节点是叶子节点 二分当前区间，递归建树 注意，这里有两个尚未出现的东西，$pushup$函数和$lztag$标记 $pushup$函数用于从子节点向上依次更新父节点的值 而$lztag$是用于区间修改的懒标记 123456789void buildTree(LL p,LL l,LL r){ lztag[p]=0; if(l==r) {Tree[p]=a[l];return ;} LL mid=(l+r)&gt;&gt;1; buildTree(getLeftNum(p),l,mid); buildTree(getRightNum(p),mid+1,r); pushup(p);} pushup 操作$pushup$起到更新的作用，对于不同的需求，有不同的$pushup$操作 对于求和，可以这么写 1234inline void pushup(LL p){ Tree[p]=Tree[getLeftNum(p)]+Tree[getRightNum(p)]);} 而对于求 最大值/最小值 ，则可以这么写 12345inline void put_up(LL p){ Tree[p]=max(Tree[getLeftNum(p)],Tree[getRightNum(p)]); //Tree[p]=min(Tree[getLeftNum(p)],Tree[getRightNum(p)]);} 更新操作更新操作可以分为两种 * 单点操作 * 区间操作 单点操作（updataPot）明确变量名： 1. （l ~ r） —— 可支配区间 2. （nedChangeL ~ nedChangeR） —— 需操作区间 3. mid —— 可支配区间中点 注 : 当$mid$不小于$nedChangeL$时 代表去 $l$ ~ $mid$ 更新是有意义的，所以，我们选择更新该区间 $mid$和$nedChangeR$同理 12345678void updataPot(LL nedChangeL,LL nedChangeR,LL l,LL r,LL p,LL num){ if(l==r) {Tree[p]=num;return ;} LL mid=(l+r)&gt;&gt;1; if(nedChangeL&lt;=mid) updata(nedChangeL,nedChangeR,l,mid,getLeftNum(p),num); if(nedChangeR&gt;mid) updata(nedChangeL,nedChangeR,mid+1,r,getRightNum(p),num); put_up(p);} 区间操作（updataInterval）区间操作需要引入一个概念 $lazytag$ : $lazytag$标注的是线段树中每个树的变化量，即 $\\Delta$ $lazytag$ 操作时正如其名，只对目前状态打上标记，等到更新时，才向下传递 因此，引入另一个函数$pushdown$，用于更新其子节点的$lazytag$和本节点的数值 接下来给出$pushdown$的代码 123456789101112inline void updataSum(LL p,LL l,LL r,LL num){ lztag[p]=lztag[p]+num; Tree[p]+=num*(r-l+1);}inline void put_down(LL p,LL l,LL r){ LL mid=(l+r)&gt;&gt;1; updataSum(getLeftNum(p),l,mid,lztag[p]); updataSum(getRightNum(p),mid+1,r,lztag[p]); lztag[p]=0;} 有了$pushdown$算法，我们可以完成$updata$操作 123456789void updataInterval(LL needChangeL,LL needChangeR,LL l,LL r,LL p,LL num){ if(needChangeL&lt;=l&amp;&amp;r&lt;=needChangeR) {updataSum(p,l,r,num);return ;} put_down(p,l,r); LL mid=(l+r)&gt;&gt;1; if(needChangeL&lt;=mid) updata(needChangeL,needChangeR,l,mid,getLeftNum(p),num); if(needChangeR&gt;mid) updata(needChangeL,needChangeR,mid+1,r,getRightNum(p),num); put_up(p);} 区间求值（query）区间求值时，我们进行了询问，而因为$lazytag$的原因，在求值之前，需先进行$pushdown$操作 12345678910LL getSum(LL qx,LL qy,LL l,LL r,LL p){ LL sum=0; if(qx&lt;=l&amp;&amp;r&lt;=qy)return Tree[p]; LL mid=(l+r)&gt;&gt;1; put_down(p,l,r); if(qx&lt;=mid)sum+=getSum(qx,qy,l,mid,getLeftNum(p)); if(qy&gt;mid) sum+=getSum(qx,qy,mid+1,r,getRightNum(p)); return sum;} END","link":"/posts/7674/"},{"title":"位运算","text":"1.&amp;如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。 注：下面都用8位的 unsigned char 来做例子。 &amp;简单举例：1234567811&amp;3 = 3 00001011&amp; 00000011= 00000011 = 3 &amp;比较实用的例子：我们经常要用的是否被2整除，一般都写成 if(n % 2 == 0) 可以换成 if((n&amp;1) == 0) 2.|如果两个相应的二进制位只要有一个是1，结果就是1；否则为0。 | 简单例子：12345678911 | 3 = 11 00001011| 00000011= 00001011 = 11 | 比较实用的例子可以用一个unsigned int 来存储多个布尔值。比如一个文件有读权限，写权限，执行权限。看起来要记录3个布尔值。我们可以用一个unsigned int也可以完成任务。 一个数r来表示读权限，它只更改个位来记录读权限的布尔值 00000001 (表示有读权限) 00000000 (表示没有读权限) 一个数w表示写权限，它只用二进制的倒数第二位来记录布尔值 00000010 (表示有写权限) 00000000 (表示没有写权限) 一个数x表示执行权限，它只用倒数第三位来记录布尔值 00000100 (表示有执行权限) 00000000 (表示没有执行权限) 那么一个文件同时没有3种权限就是 ~r | ~ w | ~ x 即为 00000000，就是0 只有读的权限就是 r | ~w | ~x 即为 00000001，就是1 只有写的权限就是 ~r | w | ~x 即为 00000010，就是2 一个文件同时有3种权限就是 r | w | x 即为 00000111，就是7 3. &lt;&lt; 向左移位移&lt;&lt;简单例子(向左移一位，右边自动补0)11 &lt;&lt; 1 = 22 00001011 &lt;&lt; 1 00010110 = 22 相当于二进制的每个数都变成当前值的两倍，结果就是变成当前值的两倍。 n * 2 == (n &lt;&lt; 1) 4. &gt;&gt; 向右位移&gt;&gt;简单例子(向右移一位，左边自动补1)1234511 &gt;&gt; 1 = 500001011 &gt;&gt; 100000101 = 5 注意到最后一位的1被干掉了。 比较实用的例子是: int n = n / 2 等价于 int n = n &gt;&gt; 1 等价于 int n &gt;&gt;= 1 5. ^ 异或两个相同的数会变成0，反之是1 123456711^3 = 8 00001011^ 00000011= 00001000 = 8 Given an array of integers, every element appearstwice except for one. Fnd that single one. 在一个数组中，所有数字都出现了两次，只有一个没有 异或是嫉妒成双成对的。 比如 int t = {1,2,3,3,2,1,5} 要找到5。 用异或就完美了，所有相同的都会消失，留下来的就是5了。 12345678intsingleNumber(int A[], int n){ for(int i = 1; i &lt; n; ++i) { A[0] ^= A[i]; } return A[0]; } 还有就是用不tmp值来交换两个数 1234567//不用temp交换两个整数voidswap(int&amp; x , int&amp; y){ x ^= y; y ^= x; x ^= y;} 6.~这个在加法中用到 x-y = x + ~y + 1 所以~y = - y -1 比如 ~11 = -11 -1 = -12 7.%(快速取模)求 100 % 8的 优化解法。 我们知道8刚好是2的3次方， 所以 100 % 8 == 100 - math.floor(100 / 8) * 8 == 100 - ((100 &gt;&gt; 3) &lt;&lt; 3)。","link":"/posts/60366/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/posts/1243066710/"},{"title":"英语语法","text":"非谓语动词非谓语动词在句子中用于定语，表语，补语 常见形式如下： | 动词形式 | 语态 | 时间范围 | 通常意义 | 是否可作主语 | | :———-: | :–: | :——-: | :—————————————: | :———-: | | doing | 主动 | 一般 | 表示一个通常的动作 | √ | | done | 被动 | 完成 | 表被动，已经被完成 | × | | to do | 主动 | 一般 | 表目的，去向，意图，具体的一次动作 | √ | | having done | 主动 | 完成 | 当动作有先后常用，注意与done区分 | √ | | being done | 被动 | 完成/进行 | 可表示正在被完成/进行，注意与done区分 | √ | | to be done | 被动 | 将来 | 可表示将要被…，注意与done区分 | √ | | to have done | 主动 | 将来完成 | 表将要完成..，注意与done区分 | √ | e.g. doing Tom stood there，wondering what he could do for the poor man sitting beside him． done Dr. Lee was very happy to see his mother taken good care of at home. to do To catch the early flight,we ordered a taxi in advance and got up very early. having done Having worked for two days, Steve managed to finish his report on schedule. being done The meeting being held now is of great importance. to be done I have a car to be repaired. to have done You are lucky to have got a ticket.","link":"/posts/683983/"},{"title":"bitset讲解","text":"为了写一道毒瘤题，决定学一下 bitset 头文件 #include&lt;bitset&gt; 同时需要命名空间 std 定义12bitset &lt;N&gt; bs// 默认的构造函数将其初始为全0 有一个值得注意的地方，bitset 的 $bs[0]$ 是最后一位，而 $bs[N-1]$ 是第一位 123std::bitset&lt;8&gt; bs;//bs[0] = 1; // 0000 0001//bs[7] = 1; // 1000 0000 构造函数12345678910std::bitset&lt;8&gt; bs(7); // 0000 0111std::bitset&lt;8&gt; bs(0x07); // 0000 0111bitset&lt;numeric_limits&lt;unsigned short&gt;::digits&gt; bs1(267); // 16位 bitset&lt;numeric_limits&lt;unsigned long&gt;::digits&gt; bs2(267); // 32位std::bitset&lt;8&gt; bs(\"00000111\"); // 7 操作|成员函数 | 功能| | —— | —— | | bs.any() | 是否存在值为 1 的二进制位 | | bs.none() | 是否不存在值为 1 的二进制位 或者说是否全部位为 0 | | bs.size() | 位长，也即是非模板参数值 | | bs.count() | 值为 1 的个数 | | bs.test(pos) | 测试 pos 处的二进制位是否为 1 返回和0做或运算的值 | | bs.set() | 全部位置重置为 1 | | bs.set(pos) | pos 位的二进制位置与 1 做或运算 | | bs.reset() | 全部位置重置为 0 | | bs.reset(pos) | pos 位的二进制位置与 0 做或运算 | | bs.flip() | 全部位逐位取反 | | bs.flip(pos) | pos处的二进制位取反 | | bs.to_ulong() | 将二进制转换为unsigned long输出 | | bs.to_string() | 将二进制转换为字符串输出 | | ~bs | 按位取反 效果等效为 bs.flip() | | os &lt;&lt; b | 将二进制位输出到os流 小值在右，大值在左 | 运算bitset 的运算就像一个普通的整数一样，可以进行 与 ( &amp; ) 、或 ( | ) 、 异或 ( ^ )、 左移 ( &lt;&lt; ) 、 右移 ( &gt;&gt; ) 等操作。 1234567891011121314151617181920bitset&lt;4&gt; foo (std::string(\"1001\"));bitset&lt;4&gt; bar (std::string(\"0011\"));cout &lt;&lt; (foo^=bar) &lt;&lt; '\\n'; // 1010 (XOR,assign)cout &lt;&lt; (foo&amp;=bar) &lt;&lt; '\\n'; // 0010 (AND,assign)cout &lt;&lt; (foo|=bar) &lt;&lt; '\\n'; // 0011 (OR,assign)cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; '\\n'; // 1100 (SHL,assign)cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; '\\n'; // 0110 (SHR,assign)cout &lt;&lt; (~bar) &lt;&lt; '\\n'; // 1100 (NOT)cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; '\\n'; // 0110 (SHL)cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; '\\n'; // 0001 (SHR)cout &lt;&lt; (foo==bar) &lt;&lt; '\\n'; // false (0110==0011)cout &lt;&lt; (foo!=bar) &lt;&lt; '\\n'; // true (0110!=0011)cout &lt;&lt; (foo&amp;bar) &lt;&lt; '\\n'; // 0010cout &lt;&lt; (foo|bar) &lt;&lt; '\\n'; // 0111cout &lt;&lt; (foo^bar) &lt;&lt; '\\n'; // 0101 参考资料 C++ Reference CSDN by Inside_Zhang 胡小兔的OI博客","link":"/posts/36423/"},{"title":"莫队","text":"我们使用一道例题来帮助我们理解莫队算法 洛谷P1972 例题题目描述:HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后， 他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此， 他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？ 这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你来解决这个问题。 输入输出格式:输入格式：第一行：一个整数N，表示项链的长度。 第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。 第三行：一个整数M，表示HH 询问的个数。 接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。 输出格式：M 行，每行一个整数，依次表示询问对应的答案。 输入输出样例输入样例#1:12345661 2 3 4 3 531 23 52 6 输出样例#1：123224 引入想象一下，如果用暴力算法进行求解的话，我们会选择开一个$cnt$数组，遍历区间，累加求解， 显然，这样的时间复杂度太高，肯定会爆掉，所以我们需要莫队算法 首先，我们定义两个指针$curl$，$curr$，每次询问我们通过移动这两个指针来框定区间， 假设一开始 $curl$ 指向 $4$ ，$curr$ 指向 $6$， 下一个询问要求区间 $3$ ~ $5$，那么我们 $curl–$ ，顺带插入 $3$ ，$curr–$，顺带删去 $6$， 注意当前的先后顺序 $curl–$ 要求先减后加入，而 $curr–$ 要求先删去再减 同理，$curl++$ 要求先删去再加，而 $curr++$ 要求先加再加入 我们可以写出这一部分 123456789int lsans;//表示该区间的答案inline void add(int pos){lsans+=(++cnt[a[pos]]==1);}//加入inline void del(int pos){lsans-=(--cnt[a[pos]]==0);}//删去while(curr&lt;rr) add(++curr);//变化范围while(curr&gt;rr) del(curr--);while(curl&gt;ll) add(--curl);while(curl&lt;ll) del(curl++); 莫队的优化我们可以很容易的发现，如果面对特别设计的数据，上面的时间复杂度仍然很高 举个栗子，有6个询问如下： 1(1, 100) (2, 2) (3, 99) (4, 4) (5, 102) (6, 7) 我们如果直接按左端点上升排序， 用上述方法处理时，左端点会移动$6$次，右端点会移动移动$98+97+95+98+95=483$次。 我们可以先按左端点上升排序，如果左端点所在的块相同，再在块内按右端点上升排序，得到结果就像这样 1(2, 2) (4, 4) (6, 7) (5, 102) (3, 99) (1, 100) 左端点移动次数为$2+2+1+2+2=9$次，比原来稍多。右端点移动次数为$2+3+95+3+1=104$，右端点的移动次数大大降低了。 $Code$：123456789struct ques{ int l , r , id ;}que[100005];bool cmp(const ques &amp;a,const ques &amp;b) { return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;} 最终的代码12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;#define sync_with_stdio(false)using namespace std;inline int read(){ int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')w=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;}struct ques{ int l , r , id ;}que[100005];int n,m, blo,lsans;bool cmp(const ques &amp;a,const ques &amp;b) {return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;}int a[100005],cnt[1000005],ans[100005];inline void add(int pos){lsans+=(++cnt[a[pos]]==1);}inline void del(int pos){lsans-=(--cnt[a[pos]]==0);}int main(){ n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); m=read();blo=sqrt(m); for(int i=1;i&lt;=m;i++) { que[i].l=read(),que[i].r=read(); que[i].id=i; } sort(que+1,que+m+1,cmp); int curl=0,curr=0; for(int i=1;i&lt;=m;i++) { int ll=que[i].l,rr=que[i].r,idd=que[i].id; while(curr&lt;rr) add(++curr); while(curr&gt;rr) del(curr--); while(curl&gt;ll) add(--curl); while(curl&lt;ll) del(curl++); ans[idd]=lsans; } for(int i=1;i&lt;=m;i++) printf(\"%d\\n\", ans[i]);}","link":"/posts/20389/"},{"title":"数论","text":"又开了一个丧心病狂的大坑，~~几个月都打不完~~，希望noip前可以打的完吧~~（又是一个flag）~~ 最大公约数（GCD）一般使用欧几里得算法（辗转相除法）求最大公约数，但在高精情况下，%运算过慢，我们使用更相损减术来代替 12345int gcd(int x,int y)//辗转相除法{ if(y==0) return x; return gcd(y,x%y);} 123456789int gcd(int a,int b)//更相损减术{ while(a!=b) { if(a&gt;b) a-=b; else b-=a; } return a;} 最小公倍数（LCM）求两个数 $x$，$y$ 的最小公倍数，易得 $lcm(x,y)=\\frac {x*y}{gcd(x,y)}$ 素数暴力求解没啥好说的。。。时间复杂度 $O(n^2)$ 123456bool is_prime(int x){ for(int i=2;i&lt;=sqrt(x);i++) if(x%i==0) return 0; return 1;} Eratosthenes筛法（埃氏筛）我们倒着来想，因为一个数的倍数不可能是质数，所以我们从 $2$ 开始往上筛，发现一个数没有被标记过，那么这个数肯定就是一个质数，再把它的倍数打个标记，时间复杂度 $O(nloglogn)$ 1234567891011121314//求1~n的所有质数bool prime[10000000+5];int n;void get_prime(int n){ int i, j; for (i=1;i&lt;=n;i++) prime[i]=1; prime[1]=0; for (i=2; i&lt;=n; i++) { if (!prime[i]) continue; for (j=i*2;j&lt;=n;j+=i) prime[j]=0; }} Euler筛法（欧拉筛）欧拉筛是埃氏筛的优化，在埃氏筛的过程中，我们可以发现有一些数被筛了多次，例如 $6$ ,在 $2$ 和 $3$ 的时候都被筛了一次，假如我们可以避免这些重复，我们就可以做到 $O(n)$ 的时间复杂度，先给出代码 12345678910111213141516//求1~n的所有质数int prime[10000000+5],ntpri[10000000+5],tot;int n;void get_prime(){ ntpri[1]=1; for(int i=2;i&lt;=n;i++) { if(!ntpri[i]) pri[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;j++) { ntpri[pri[j]*i]=1; if(i%pri[j]==0) break;//关键 } }} 这句 if(i%pri[j]==0) break; 是关键所在 假设我们筛到了第 $i$ 个数，循环到 $prime[j]$ ， 如果 $prime[j]|i$ ，那么必定有一个数 $x$ ，使得 $i=x \\cdot prime[j]$ ， 那么如果下一个数 $prime[j+1]$ 和 $i$ 相乘，就会得到一个数 $p$ ， 而 $p=prime[j+1] \\cdot i=prime[j+1] \\cdot x \\cdot prime[j]=k*prime[j]$ 设 $k=prime[j+1] \\cdot x$ ， 即 $prime[j+1] \\cdot i=k \\cdot prime[j]$ 所以在未来一定有一个数乘以 $prime[j]$ 恰好可以把 $p$ 筛掉，不必要再到 $prime[j+1]$ 筛这个数 Miller Rabin算法Miller Rabin 是依据于费马小定理的一个 随机算法 ，先介绍费马小定理 $$ a^{P-1}\\equiv 1(modP) $$ 其中 $P$ 为质数，且 $gcd(a,P)=1$ ， 假如有一个数 $P$ 对于任何 $a$ 满足该性质，那么 $P$ 是不是就是质数呢？ 然而这是错误的，我们有一个~~专门针对它~~的反例： 卡迈克尔数（Carmichael数） 卡迈克尔数的定义是对于合数 $n$，如果对于所有正整数 $b$，$b$ 和 $n$ 互素， 都有同余式 $b^{N-1}≡ 1 (mod N)$ 成立，则合数 $n$ 为Carmichael数。 但是我们任然可以通过费马小定理来求素数，毕竟100000000以内只有255个卡米切尔数， 只要我们多次计算，任然可以保证 99.9% 以上的正确率， ~~但它还是个玄学算法，当然你也可以背下一些int以内所有卡迈克尔数~~ ， ~~先咕咕咕~~ 矩阵矩阵乘法举个栗子（来自百度百科） 设 $A$ 为 $n \\times k$ 阶的矩阵 ，$B$ 为 $k \\times m$ 阶的矩阵 则 $C=A \\cdot B$ 可以表示为 $C_{i,j}=\\sum_{p=1}^{k}A_{i,p} \\times B_{p,j}$ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int a[105][105];int b[105][105];int c[105][105];int main() { int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) for(int t=1;t&lt;=m;t++) cin&gt;&gt;a[i][t]; for(int i=1;i&lt;=m;i++) for(int t=1;t&lt;=k;t++) cin&gt;&gt;b[i][t]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) for(int t=1;t&lt;=m;t++) c[i][j]+=a[i][t]*b[t][j]; for(int i=1;i&lt;=n;i++) { for(int t=1;t&lt;=k;t++) cout&lt;&lt;c[i][t]&lt;&lt;' '; puts(\"\"); }} 矩阵快速幂先讲 快速幂，还是利用二进制的思想 12345678910111213//求x的k次方typedef long long LL;LL fastpow(LL x,LL k)｛ LL ans=1; while(k) { if(k&amp;1) ans*=x; x*=x; k&gt;&gt;=1; } return ans;｝ 矩阵快速幂就是把乘换成矩阵乘QWQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL M=1e9+7;struct data { LL matrix[105][105];};data a,eans;LL n,k;data mul(data a,data b) { data ans; memset(ans.matrix,0,sizeof(ans.matrix)); for(int i=1; i&lt;=n; ++i) { for(int k=1; k&lt;=n; ++k) { for(int t=1; t&lt;=n; ++t) { ans.matrix[i][k]=ans.matrix[i][k]%M+a.matrix[i][t]*b.matrix[t][k]%M; } } } return ans;}data fastpow(data a,LL b) { data ans; for(int i=1; i&lt;=n; ++i) ans.matrix[i][i]=1; while(b!=0) { if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b&gt;&gt;=1; } return ans;}int main() {// freopen(\"testdata (1).in\",\"r\",stdin);// freopen(\"1.txt\",\"w\",stdout); cin&gt;&gt;n&gt;&gt;k; for(int i=1; i&lt;=n; ++i) for(int k=1; k&lt;=n; ++k) cin&gt;&gt;a.matrix[i][k]; eans=fastpow(a,k); for(int i=1; i&lt;=n; ++i) { for(int k=1; k&lt;=n; ++k) cout&lt;&lt;eans.matrix[i][k]%M&lt;&lt;' '; cout&lt;&lt;endl; }} 矩阵加速 ~~咕咕咕~~ 逆元费马小定理EXGCD线性求逆元计算相关高斯消元BSGS算法高精FFTNTT组合数学lucas定理Burnside引理Polya定理群置换群及轮换反演积性函数欧拉函数莫比乌斯函数原根卷积莫比乌斯反演杜教筛洲阁筛杂项裴蜀定理欧拉定理中国剩余定理","link":"/posts/15425/"},{"title":"最小生成树","text":"最小生成树有两种算法 Prim &amp; Kruskal 1. Prim1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define inf 0x7fffffff#define maxn 5005int cost[maxn][maxn],minn,n,m,v2[maxn],tot=1,now,ans;bool v1[maxn];inline void getcost(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { cost[i][j]=inf; } } for(int i=1,u,v,w; i&lt;=m; i++) { scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); if(cost[u][v]&gt;w) { cost[u][v]=cost[v][u]=w; } }//初始化cost数组 for(int i=1; i&lt;=n; i++) { v2[i]=cost[1][i]; } v1[1]=1;//找出与1节点相连的边并进行标记}inline int prim(){ while(tot&lt;n) { //最小生成树的概念 minn=inf; tot++; for(int i=1; i&lt;=n; i++) { if(!v1[i]&amp;&amp;v2[i]&lt;minn) { minn=v2[i]; now=i; } }//找出最小边 ans+=minn;//更新答案 for(int i=1; i&lt;=n; i++) { if(v2[i]&gt;cost[now][i]&amp;&amp;!v1[i]) { v2[i]=cost[now][i]; } } v1[now]=1;//在找出与now节点相连的边并进行标记 } return ans;}int main(){ getcost(); printf(\"%d\",prim()); return 0;//主函数不解释} 2. Kruskal1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define max(a,b) return a&gt;b?a:b using namespace std;struct Edge{int pointA,pointB,w;}edge[200005];int father[5005],n,m,ans,eu,ev,cnt;inline bool cmp(Edge a,Edge b){return a.w&lt;b.w;}//快排的依据inline int findfather(int x){ while(x!=father[x]) x=father[x]=father[father[x]]; return x;}//并查集模板，用while循环比递归版快inline void kruskal(){ sort(edge+1,edge+m+1,cmp);//将边的权值排序 for(int i=1;i&lt;=m;i++){ eu=findfather(edge[i].pointA), ev=findfather(edge[i].pointB); if(eu==ev) continue;//若出现环，则continue ans+=edge[i].w;//更新答案 father[ev]=eu; cnt++; if(cnt==n-1) break;//循环结束条件 }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) father[i]=i;//初始化并查集 for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;edge[i].pointA,&amp;edge[i].pointB,&amp;edge[i].w); kruskal(); printf(\"%d\",ans); return 0;}","link":"/posts/57313/"},{"title":"树上差分-题解","text":"都是水题啦，你们都能一眼秒的 EOJ Monthly 2018.8 D.Delivery（水题）题目描述 有一棵 $N$ 个节点的树 ，树的每条边都有各自的权值 $W_i$ ，在询问开始前，可以交换任一两条边的权值，次数不限，有 $q$ 个询问，每个询问包含一个起点 $S_i$ 和终点 $T_i$ ，从起点到终点经过的边的权值和就是这次询问的花费，求所有询问的最小花费和 $$ 1 \\leq n \\leq 2 \\times 10^5,1 \\leq q \\leq 2 \\times 10^5 $$ $$ 1 \\leq u_i,v_i \\leq n,u_i \\neq v_i $$ $$ 1 \\leq w_i \\leq 1000 $$ $$ 1 \\leq s_i,t_i \\leq n,s_i \\neq t_i $$ 题解这就是求边覆盖次数的裸题啊，覆盖边按覆盖次数给予从小到大的权值就结束啦 太水不贴代码 BZOJ4424/CF19E Fairy（大水题）题目描述 给定 $N$ 个点，$M$ 条边的无向图，可以从图中删除一条边，问删除哪些边可以使图变成一个二分图。 $$ 1 \\leq n,m \\leq 1000000 $$ 题解首先二分图是没有奇环的，我们要删边来去掉奇环 只有一条边被所有的奇环覆盖时才能去删它，这样才能保证没有奇环 如果这条边被偶环覆盖的话，无论怎么删都会出现一个新奇环，这条边是不能删的 我们对图 $dfs$ 遍历，对边新建出一棵树 然后这个边的覆盖问题就可以通过树上差分解决 $code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485struct data{ int nxt,to,id;}edge[N&lt;&lt;1];struct EDGEE{ int nxt,to;}edge2[N&lt;&lt;1]; int n,m,tot=0,tot2=0,top=0,cnt=0,cnt2=0;int head[N],head2[N],sta[N&lt;&lt;1],pos[N&lt;&lt;1],vis[N&lt;&lt;1],vis2[N&lt;&lt;1],sum[N&lt;&lt;1],fir[N&lt;&lt;1],ans[N];inline void add(int x,int y,int i){ edge[++tot].nxt=head[x]; edge[tot].to=y; edge[tot].id=i; head[x]=tot;}inline void add2(int x,int y){ edge2[++tot2].nxt=head2[x]; edge2[tot2].to=y; head2[x]=tot2;}void dfs(int now,int fa,int pre_id){ sta[++top]=now;pos[now]=top;vis[now]=1; for(int i=head[now];i;i=edge[i].nxt) { int tt=edge[i].to,nid=edge[i].id; if(nid==pre_id) continue; if(!vis2[nid]) vis2[nid]=1,add2(pre_id,nid),add2(nid,pre_id); if(!pos[tt]) fir[tt]=nid,dfs(tt,now,nid); else if(vis[tt]) { if((pos[now]-pos[tt]+1)&amp;1) sum[nid]++,sum[fir[tt]]--,cnt++; else sum[nid]--,sum[fir[tt]]++; } } vis[now]=0;top--;} void dfs2(int now,int fa){ for(int i=head2[now];i;i=edge2[i].nxt) { int tt=edge2[i].to; if(tt==fa) continue; dfs2(tt,now); sum[now]+=sum[tt]; } if(sum[now]==cnt) ans[++cnt2]=now;}int x,y;int main(){ #ifdef ROY1994 freopen(\"testdata.in\",\"r\",stdin); freopen(\"A.out\",\"w\",stdout); #endif io&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) { io&gt;&gt;x&gt;&gt;y; add(x,y,i); add(y,x,i); } for(int i=1;i&lt;=n;i++) if(!pos[i]) dfs(i,0,0); dfs2(0,0); if(!cnt) { io&lt;&lt;m&lt;&lt;'\\n'; for(int i=1;i&lt;=m;i++) io&lt;&lt;i&lt;&lt;' '; io&lt;&lt;'\\n'; return 0; } sort(ans+1,ans+cnt2+1); io&lt;&lt;cnt2&lt;&lt;'\\n'; for(int i=1;i&lt;=cnt2;i++) io&lt;&lt;ans[i]&lt;&lt;' '; io&lt;&lt;'\\n'; return 0;} 2017 SEERC L. Divide and Conquer（巨水题）题目描述 有一个有 $N$ 个点的由两棵不同的树构成的复合图(无重边)。 问最少切断几条边，可以使原图不联通。并输出方案数 $$ 1 \\leq n \\leq 1000000 $$ 题解首先切断的边数肯定是 2 ~ 3 这是两棵树组成的图，所以只有 $2N-2$ 条边， 假设切断 4 条边才能保证不联通，那么至少要有 $2N$ 条边，很显然矛盾 所以肯定切断 2 ~ 3 条边 那么必然是一颗树上切断 1 条边，另一颗树上切断 1 ~ 2 条边 我们先以 $A$ 树为主，把 $B$ 树的边作为返祖边/横插边 那么就相当于求横跨 $A$ 树的属于 $B$ 树的边数， 这个可以通过树上差分解决 每个节点的 $sum$ 就是横跨其的 $B$ 树边数 我们对 $sum+1$ 取最小值 $minn$ 并记录方案数 如果 $minn=2$ 直接输出 如果 $minn=3$ 因为可以 $A$ 树断 2 条， $B$ 树断 1 条 我们交换再统计一次方案加上之前的就是方案数 $code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;inline int read(){ int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')w=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;}const int N=100005;struct data{ int from,to;}A[N&lt;&lt;1],B[N&lt;&lt;1];struct EDGEE{ int nxt,to;}edge[N&lt;&lt;1];int tot=0,head[N];int f[N][30],dep[N],sum[N],q[N&lt;&lt;2];int n,stp,ans,minn=0x7fffffff;int m1,m2;inline void add(int x,int y){ edge[++tot].nxt=head[x]; edge[tot].to=y; head[x]=tot;}void bfs(){ int Head=1,tail=0; dep[1]=1;f[1][0]=0; q[++tail]=1; while(Head&lt;=tail) { int now=q[Head++]; for(int i=head[now];i;i=edge[i].nxt) { int tt=edge[i].to; if(dep[tt]) continue ; dep[tt]=dep[now]+1; f[tt][0]=now; for(int j=1;j&lt;=stp;j++) f[tt][j]=f[f[tt][j-1]][j-1]; q[++tail]=tt; } }}inline int lca(int x,int y){ if(dep[x]&lt;dep[y]) swap(x,y); for(int i=stp;i&gt;=0;i--) if(dep[f[x][i]]&gt;=dep[y]) x=f[x][i]; if(x==y) return x; for(int i=stp;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];}void dfs(int x){ for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==f[x][0]) continue; dfs(tt); sum[x]+=sum[tt]; } if(x==1) return ; if(sum[x]+1&lt;minn) minn=sum[x]+1,ans=1; else if(sum[x]+1==minn) ans++;}inline void ADD(int ff){ if(ff==1) for(int i=1;i&lt;n;i++) add(A[i].from,A[i].to),add(A[i].to,A[i].from); else for(int i=1;i&lt;n;i++) add(B[i].from,B[i].to),add(B[i].to,B[i].from); }inline void ClearE(){ memset(edge,0,sizeof(edge)); memset(head,0,sizeof(head)); memset(sum,0,sizeof(sum)); memset(dep,0,sizeof(dep)); memset(f,0,sizeof(f)); tot=0;}int x,y;int main(){// freopen(\"ME.in\",\"r\",stdin);// freopen(\"ME.out\",\"w\",stdout); n=read(); stp=(int)log2(n)+1; for(int i=1;i&lt;n;i++) { x=read();y=read(); A[i].from=x,A[i].to=y; } for(int i=1;i&lt;n;i++) { x=read();y=read(); B[i].from=x,B[i].to=y; } ADD(1); bfs(); for(int i=1;i&lt;n;i++) { sum[B[i].from]++; sum[B[i].to]++; sum[lca(B[i].from,B[i].to)]-=2; } dfs(1); if(minn==2) { printf(\"%d %d\\n\",minn,ans); return 0; } ClearE(); ADD(2); bfs(); for(int i=1;i&lt;n;i++) { sum[A[i].from]++; sum[A[i].to]++; sum[lca(A[i].from,A[i].to)]-=2; } dfs(1); printf(\"%d %d\\n\",minn,ans); return 0;}","link":"/posts/2952530072/"},{"title":"树的直径-题解","text":"都是水题啦，你们都能一眼秒的 BZOJ1999 [Noip2007] Core树网的核题目描述 给定一棵带边权无根树，在其直径上求出一段长度不超过 $s$ 的路径 $F$ ，使得离路径距离最远的点到路径的距离 $ECC$ 最短。 点 $v$ 到路径 $F$ 距离 $D(v,𝐹)$ $=$ $min⁡$ { $d(v,u)$ } , $u$ 为路径上的点 $$ n \\leq 500000,s &lt; 2^{32} ，所有边权&lt;500 $$ 题解对距离 $ECC$ 产生贡献的点来自以下几个部分 直径的端点 路径上的点到非直径上点的距离 对于直径的端点，我们有个结论，离一个点距离最远的点是直径的一个端点 因而我们无需考虑直径上除端点外的其它点， 那么路径 $F$ 尽可能大，才能保证这部分贡献尽可能小 但这只是一个部分，我们还要考虑路径上的点到非直径上点的距离的贡献 这部分贡献可能会更大，使实际上的距离 $ECC$ 比直径的端点影响造成的 $ECC$ 大， 以至于掩盖住直径的端点的贡献，所以我们要取 $max$ 保证符合定义 求这部分贡献可以对路径上每个点 $dfs$ 解决 因为在直径上且在路径外的点到非直径点的距离一定小于等于直径的端点的贡献 没有影响，为了方便，我们对整个直径上的的点 $dfs$， $code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define min(a,b) ((a)&lt;(b))?(a):(b)#define max(a,b) ((a)&gt;(b))?(a):(b)#define INF 0x7fffffffusing namespace std;inline void read(int &amp;x){ x=0;char ch;int f=1;ch=getchar(); for(;!isdigit(ch);) {if(ch=='-') f=-1;ch=getchar();} for(;isdigit(ch);) x=x*10+(ch^48),ch=getchar(); x*=f;}const int N=500005;struct EDGEE{ int nxt,wei,to;}edge[N&lt;&lt;1];int head[N],tot;inline void add(int x,int y,int v){ edge[++tot].nxt=head[x]; edge[tot].to=y; edge[tot].wei=v; head[x]=tot;}int n,s,maxn,maxp,ls;int dep[N],is_d[N],pre[N];void dfs(int x,int fa){ pre[x]=fa; if(dep[x]&gt;maxn) { maxp=x; maxn=dep[x]; } for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa||is_d[tt]) continue; dep[tt]=dep[x]+edge[i].wei; dfs(tt,x); }}int x,y,w,ans=INF;int main(){ read(n);read(s); for(int i=1;i&lt;n;i++) { read(x);read(y);read(w); add(x,y,w);add(y,x,w); } maxn=-INF; dep[1]=0; dfs(1,0); ls=maxp; maxn=-INF; dep[ls]=0; dfs(ls,0); for(int i=maxp,j=maxp;i;i=pre[i]) { while(dep[j]-dep[i]&gt;s) j=pre[j]; ans=min(ans,max(dep[i],maxn-dep[j])); } for(int i=maxp;i;i=pre[i]) is_d[i]=1; for(int i=maxp;i;i=pre[i]) { dep[i]=0; dfs(i,pre[i]); } for(int i=1;i&lt;=n;i++) ans=max(ans,dep[i]); printf(\"%d\",ans); } UVA11695 Flight Planning题目描述 给一个 $N$ 个节点边权为 1 的无根树，去掉一条边，新增一条边，求新的树的最长链，问怎么去边和加边，使得最长链的长度最小 $$ 1 \\leq n \\leq 2500 $$ 题解我们可以枚举每一条要删去的边 去掉这条边后，最小的树的直径会出现在以下几种情况中 子树 $A$ 的直径 子树 $B$ 的直径 加边后树的直径 子树 $A$ ，$B$ 的直径是固定的，所以我们要保证加边后树的直径最小 所以要在子树中找到一个点使其到该子树其他点的最大距离最小 很显然，这个点一定是直径的中点， 子树的这两个点就是要连边的节点 $code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#define INF 0x7fffffffusing namespace std;inline void read(int &amp;x){ x=0;char ch;int f=1;ch=getchar(); for(;!isdigit(ch);) {if(ch=='-') f=-1;ch=getchar();} for(;isdigit(ch);) x=x*10+(ch^48),ch=getchar(); x*=f;}const int N=5005;struct EDGEE{ int nxt,from,to;}edge[N&lt;&lt;1];int head[N],tot;int T,n,x,y,addA,addB,p_addA,p_addB,lenA,lenB,delA,delB,ans=INF;int dep[N],pre[N],maxp,maxn=-INF,minn=INF,rbq,ls;inline void add(int x,int y){ edge[++tot].nxt=head[x]; edge[tot].from=x; edge[tot].to=y; head[x]=tot;}void dfs(int x,int fa,const int &amp;del){ pre[x]=fa; if(dep[x]&gt;maxn) { maxp=x; maxn=dep[x]; } for(int i=head[x];i;i=edge[i].nxt) { if(i==del||i==(del+1)) continue; int tt=edge[i].to; if(tt==fa) continue; dep[tt]=dep[x]+1; dfs(tt,x,del); }}void solve(int del){// memset(pre,0,sizeof(pre)); maxp=edge[del].from; maxn=-INF; minn=INF; dep[edge[del].from]=0; dfs(edge[del].from,0,del);// memset(pre,0,sizeof(pre)); ls=maxp; maxn=-INF; minn=INF; dep[ls]=0; dfs(ls,0,del); lenA=maxn; p_addA=maxp; for(int i=0;i&lt;lenA/2;i++) p_addA=pre[p_addA]; //--------------------------------------------------// memset(pre,0,sizeof(pre)); maxp=edge[del].to; maxn=-INF; minn=INF; dep[edge[del].to]=0; dfs(edge[del].to,0,del);// memset(pre,0,sizeof(pre)); ls=maxp; maxn=-INF; minn=INF; dep[ls]=0; dfs(ls,0,del); lenB=maxn; p_addB=maxp; for(int i=0;i&lt;lenB/2;i++) p_addB=pre[p_addB]; rbq=max(max(lenA,lenB),(lenA+1)/2+(lenB+1)/2+1);// cout&lt;&lt;\"$\"&lt;&lt;lenA&lt;&lt;' '&lt;&lt;lenB&lt;&lt;\"$\"&lt;&lt;endl; if(ans&gt;rbq) { ans=rbq; delA=edge[del].from; delB=edge[del].to; addA=p_addA; addB=p_addB; }}int main(){ read(T); for(;T--;) { memset(head,0,sizeof(head)); memset(edge,0,sizeof(edge)); tot=0;ans=INF; read(n); for(int i=1;i&lt;n;i++) { read(x);read(y); add(x,y);add(y,x); } for(int i=1;i&lt;=tot;i+=2) { solve(i); } printf(\"%d\\n\",ans); printf(\"%d %d\\n\",delA,delB); printf(\"%d %d\\n\",addA,addB); } return 0;} BZOJ1912 [APIO2010] patrol 巡逻题目描述链接 题解很显然，当 $k = 1$ 时，找到直径然后连端点就可以了 当 $k = 2$ 时，我们要找直径和边不相交的第二大直径 当两条直径相交的时候， 因为加的边必须走，所以第二条加边并没有起到缩短路程的作用，反而多花费了 $1$ 反而不如把边退化成点，长度为 $0$ 找次大直径可以把直径上的边权改成 $-1$ ，再求直径 由于出现了负边权，用 dfs/bfs 会挂 （可能是我太菜了） 所以用 $dp$ 求解 $code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define INF 0x7fffffffusing namespace std;inline void read(int &amp;x){ x=0;char ch;int f=1;ch=getchar(); for(;!isdigit(ch);) {if(ch=='-') f=-1;ch=getchar();} for(;isdigit(ch);) x=x*10+(ch^48),ch=getchar(); x*=f;}const int N=100005;struct EDGEE{ int nxt,wei,to;}edge[N&lt;&lt;1];int head[N],tot;int n,k,maxn=-INF,maxp,ls,len1,len2; int dep[N],pre[N],dis[N];inline void add(int x,int y){ edge[++tot].nxt=head[x]; edge[tot].to=y; edge[tot].wei=1; head[x]=tot;}void dfs(int x,int fa){ pre[x]=fa; if(maxn&lt;dep[x]) { maxn=dep[x]; maxp=x; } for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa) continue;// cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl; dep[tt]=dep[x]+edge[i].wei; dfs(tt,x); } }void maxlen(int x,int fa){ for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa) continue; maxlen(tt,x);// cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl; len2=max(len2,dis[x]+dis[tt]+edge[i].wei); dis[x]=max(dis[x],dis[tt]+edge[i].wei); }}void work(int x,int fa){ for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa||tt!=pre[x]) continue;// cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl; edge[i].wei=-1; edge[i&amp;1?(i+1):(i-1)].wei=-1; work(tt,x); }}int x,y;int main(){ read(n);read(k); for(int i=1;i&lt;n;i++) { read(x);read(y); add(x,y);add(y,x); } maxn=-INF; dep[1]=0; dfs(1,0); ls=maxp; maxn=-INF; dep[ls]=0; dfs(ls,0); len1=maxn; if(k==1) { printf(\"%d\",2*(n-1)-len1+1); return 0; } work(maxp,0); maxlen(1,0); printf(\"%d\",2*(n-1)-len1-len2+2);}","link":"/posts/1138517949/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"模版","slug":"模版","link":"/tags/模版/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"ZKW","slug":"ZKW","link":"/tags/ZKW/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"GAN","slug":"GAN","link":"/tags/GAN/"},{"name":"平衡树","slug":"平衡树","link":"/tags/平衡树/"},{"name":"FHQ","slug":"FHQ","link":"/tags/FHQ/"},{"name":"英语","slug":"英语","link":"/tags/英语/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"暴力","slug":"暴力","link":"/tags/暴力/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"题解","slug":"题解","link":"/tags/题解/"},{"name":"经验","slug":"经验","link":"/tags/经验/"}],"categories":[]}