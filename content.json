{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Segment Tree(ZKW)(PART TWO)","text":"æœ¬æ¥æƒ³çœ‹çœ‹ç½‘ä¸Šçš„è®²è§£çš„ï¼Œç»“æœå‘ç°éƒ½è®²å¾—ä¸æ¸…æ¥šï¼Œè¿˜æ˜¯è‡ªå·±å†™ä¸€ä¸ªå§ æ™®é€šçº¿æ®µæ ‘ä¸ZKWçº¿æ®µæ ‘ æ™®é€šçº¿æ®µæ ‘é€šè¿‡é€’å½’å»ºæ ‘ï¼Œå› è€Œå…¶å¸¸æ•°ç›¸å¯¹è¾ƒå¤§ æ™®é€šçº¿æ®µæ ‘ä»£ç é•¿ï¼Œç›¸å¯¹è¾ƒå¤æ‚ ZKWçº¿æ®µæ ‘é€šè¿‡å¾ªç¯å»ºæ ‘ï¼Œç›¸å¯¹å¸¸æ•°å° ZKWçº¿æ®µæ ‘ä»£ç çŸ­ï¼Œæ˜“ç†è§£ ZKWçº¿æ®µæ ‘ Â· æ— å·®åˆ†å¼±åŒ–ç‰ˆçº¿æ®µæ ‘æ˜¯ä¸€ç§å †å¼å‚¨å­˜ç»“æ„ï¼Œ è§‚å¯Ÿå…¶èŠ‚ç‚¹ç¼–å· å°†å…¶è½¬åŒ–æˆäºŒè¿›åˆ¶ è§„å¾‹æ˜¯å¾ˆæ˜¾ç„¶çš„ ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ˜¯è¿™ä¸ªæ•°å·¦ç§»1ï¼Œè¿™ä¸ªä½è¿ç®—å°±æ˜¯ä½ä½èˆå¼ƒï¼Œæ‰€æœ‰æ•°å­—å·¦ç§»ä¸€ä½ ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ˜¯è¿™ä¸ªæ•°å³ç§»1ï¼Œæ˜¯å·¦èŠ‚ç‚¹ï¼Œå³ç§»1 +1æ˜¯å³èŠ‚ç‚¹ åŒä¸€å±‚çš„èŠ‚ç‚¹æ˜¯ä¾æ¬¡é€’å¢çš„ï¼Œç¬¬$n$å±‚æœ‰$2^{n-1}$ä¸ªèŠ‚ç‚¹ æœ€åä¸€å±‚æœ‰å¤šå°‘èŠ‚ç‚¹ï¼Œå€¼åŸŸå°±æ˜¯å¤šå°‘(è¿™ä¸ªå¾ˆé‡è¦) æœ‰äº†è¿™äº›è§„å¾‹å°±å¯ä»¥å¼€å§‹ç€æ‰‹å»ºæ ‘äº† è‹¥æ ‘çš„å±‚æ•°ä¸º $m$ ï¼Œåˆ™æœ€åä¸€å±‚çš„èŠ‚ç‚¹æ•° $cnt$ æ»¡è¶³ $cnt = 2^{m-1}$ è‹¥æ•°çš„ä¸ªæ•°ä¸º $x$ ï¼Œåˆ™æ•°çš„ä¸ªæ•°xæ»¡è¶³ $\\frac {cnt}{2} &lt; x &lt;= cnt$ ï¼ˆå¤§äº$x$å°äº$cnt$çš„éƒ¨åˆ†æ— è§†ï¼‰ åº•å±‚èŠ‚ç‚¹åºå·ä» $cnt$ å¼€å§‹ï¼Œä¸€ç›´åˆ° $cnt+n-1$ ç»“æŸï¼Œç¬¬ $p$ ä¸ªæ•°ç¼–å·ä¸º $cnt+p-1$ æ‰€ä»¥æˆ‘ä»¬éœ€è¦å…ˆç®—å‡ºè¿™ä¸ª $cnt$ çš„æœ€å°å€¼ 1for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1);//è¿™é‡Œæ²¡æœ‰ç­‰å·ï¼Œä»¥ä¿è¯cntæœ€å° å»ºæ ‘12345678910int n,a[10005];struct node{ int num;}Tree[10005];inline void build(int n){ for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read();} è¿™ä»…ä»…æ˜¯å¯¹å¶å­èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼Œä¹‹åï¼Œæˆ‘ä»¬è¦ä¾æ¬¡æ›´æ–°çˆ¶èŠ‚ç‚¹ ç”±äºæ˜¯è‡ªä¸‹å¾€ä¸Šæ›´æ–°ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åº”å½“ä» $cnt-1$ å¼€å§‹ï¼Œä¸€ç›´åˆ° $1$ 12for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num; æœ€åçš„å»ºæ ‘ä»£ç  123456inline void build(int n){ for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read(); for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num;} å•ç‚¹æ“ä½œç›´æ¥ä¿®æ”¹ 12345inline void change(int x,int k){ Tree[cnt+x-1].num+=k; while(x) Tree[x&gt;&gt;=1].num=Tree[x&lt;&lt;1].num+Tree[x&lt;&lt;1|1].num;//æ›´æ–°} å•ç‚¹æŸ¥è¯¢ç›´æ¥ä¿®æ”¹ 1234inline int askpot(int pos){ return Tree[cnt+pos-1];} ZKWçº¿æ®µæ ‘ Â· å·®åˆ†ç‰ˆå»ºæ ‘æˆ‘ä»¬å‘ç°ï¼Œä¸Šé¢çš„æ–¹æ³•å¯¹äºåŒºé—´æ“ä½œæ—¶é—´å¤æ‚åº¦ä¼šå¾ˆé«˜ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å·®åˆ†æ€æƒ³æ¥è¿›è¡Œä¼˜åŒ– æ­¤æ—¶ï¼Œçº¿æ®µæ ‘èŠ‚ç‚¹å­˜çš„å€¼æ˜¯ä»–å’Œçˆ¶èŠ‚ç‚¹çš„å·®å€¼ æˆ‘ä»¬å†æ¥å†™ä¸€ä¸‹å·®åˆ†ç‰ˆçš„build 1234567891011void build(int n){ for (cnt = 1; cnt &lt; x; cnt &lt;&lt;= 1); for (int i = cnt; i &lt; cnt + n; i++) Tree[i].num = read(); for (int i = cnt - 1; i &gt;= 1; i--) { Tree[i].num = min(Tree[i &lt;&lt; 1].num, Tree[i &lt;&lt; 1 | 1]); Tree[i &lt;&lt; 1].num -= Tree[i]; Tree[i &lt;&lt; 1 | 1].num -= Tree[i]; }} å•ç‚¹æŸ¥è¯¢ç”±äºå·®åˆ†çš„æ€§è´¨ åªéœ€ä¾æ¬¡å‘ä¸Šç´¯åŠ å°±å¯ä»¥æ±‚å‡ºæ”¹ç‚¹çš„å€¼ 123456inline int askpot(int pos){ int sum=0,x=cnt+pos-1; while(x) sum+=Tree[x].num,x&gt;&gt;=1; return sum;} åŒºé—´æŸ¥è¯¢ 1inline int askRange(int l,int r)","link":"/posts/30408/"},{"title":"CycleGAN","text":"https://blog.csdn.net/gdymind/article/details/82696481","link":"/posts/10000/"},{"title":"Balance Tree(FHQ Treap)","text":"å¬è¯´è¿™ä¸ªå¹³è¡¡æ ‘å¾ˆ~~å¥½å†™~~ï¼Œæ‰€ä»¥æˆ‘å°è¯•å»å­¦ä¸€ä¸‹è¿™ä¸ª~~æ¯’ç˜¤~~çš„æ•°æ®ç»“æ„ FHQ Treapç®€ä»‹FHQ Treapåªæœ‰ä¸¤ç§ä¸»è¦çš„æ“ä½œ * åˆ†ç¦»ï¼ˆsplitï¼‰ æŠŠä¸€æ£µæ ‘åˆ†æˆä¸¤ä¸ªæ ‘ * åˆå¹¶ï¼ˆmergeï¼‰ æŠŠä¸¤æ£µæ ‘åˆæˆä¸€æ£µæ ‘ é€šè¿‡ åˆ†ç¦» å’Œ åˆå¹¶ çš„æ“ä½œï¼ŒFHQ Treapå¯ä»¥å®Œæˆæ™®é€šå¹³è¡¡æ ‘çš„å¾ˆå¤šæ“ä½œ æ’å…¥ åˆ é™¤ æŸ¥è¯¢æ’åä¸º $i$ çš„æ•° æŸ¥è¯¢ $wei$ çš„æ’å æ±‚ $wei$ çš„å‰é©± æ±‚ $wei$ çš„åç»§ åè½¬åŒºé—´ æ ‘çš„èŠ‚ç‚¹FHQ Treap çš„èŠ‚ç‚¹ç»´æŠ¤çš„ æ™®é€šTreap ç»´æŠ¤çš„å¤§è‡´ç›¸åŒï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç»“æ„ä½“æ¥ä¿å­˜ä¿¡æ¯ ç›¸å…³å«ä¹‰å¦‚ä¸‹ï¼š size â€”&gt; å­æ ‘ï¼ˆåŒ…æ‹¬è‡ªèº«ï¼‰çš„å¤§å° val â€”&gt; è¯¥èŠ‚ç‚¹çš„å€¼ rnd â€”&gt; Treapä¸­ç”¨äºå †çš„éšæœºå€¼ l r â€”&gt; å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹ ä¸‹é¢ç»™å‡ºä»£ç ï¼š 1234struct FHQ{ int size,val,rnd;}tr[N]; æ“ä½œ 1 : æ’å…¥æŒ‰ç…§æ™®é€štreapçš„å†™æ³•ï¼Œæˆ‘ä»¬éœ€è¦æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œéœ€è¦è°ƒç”¨newnodeå‡½æ•° 123456int tot=0;int newnode(int v){ tr[++tot].size=1;tr[tot].val=v,tr[tot].rnd=rand(); return tot;//è¿”å›æ–°èŠ‚ç‚¹çš„ç¼–å·} æˆ‘ä»¬å¯ä»¥æŠŠåŸæ¥çš„æ•°æŒ‰æ–°èŠ‚ç‚¹çš„å€¼åˆ†æˆä¸¤ä»½ï¼Œå†ä¾æ¬¡åˆå¹¶ï¼Œå°±å®Œæˆäº†æ’å…¥çš„è¿‡ç¨‹ 123456789void ins(int wei){ int x,y; spilt(root,wei,x,y); //rootè¡¨ç¤ºç›®å‰æ€»æ ‘çš„æ ¹èŠ‚ç‚¹ //æŠŠæ€»æ ‘åˆ†æˆä»¥x,yä¸ºæ ¹èŠ‚ç‚¹çš„ä¸¤æ£µæ ‘ root=merge(merge(x,newnode(wei)),y); //åˆå¹¶æ‰€æœ‰å­æ ‘å¹¶é‡ç½®æ ¹èŠ‚ç‚¹} æ“ä½œ 2 ï¼š åˆ é™¤åˆ é™¤æƒå€¼ä¸º $wei$ çš„ç‚¹ï¼Œå…ˆæŠŠæ•´é¢—æ ‘ä»¥ $wei$ ä¸ºæƒå€¼ $split$ æˆä¸¤æ£µæ ‘ $x$ï¼Œ$y$ï¼Œå†æŠŠ $x$ æ ‘æŒ‰ç…§ $wei-1$ åˆ†æˆ $p$ï¼Œ$q$ã€‚ è¿™æ—¶å€™å€¼ä¸ºweiçš„ç‚¹ä¸€å®šä¸º $q$ çš„æ ¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬æŠŠ $q$ çš„ä¸¤ä¸ªå­å„¿å­ $merge$ èµ·æ¥ï¼ˆè¿™ä¸€æ­¥å°±æ˜¯å»é™¤æ‰ $wei$ çš„å½±å“ï¼‰ï¼Œå†æŠŠä»–ä»¬é‡æ–° $merge$ èµ·æ¥å¾—åˆ°ä¸€ä¸ªæ–°çš„æ ‘ï¼Œè¿™é¢—æ ‘å°±å»é™¤æ‰äº† $wei$ çš„å½±å“ã€‚ 12345678void del(int wei){ int x,int y,int p,int q; spilt(root,wei,x,y); split(x,wei-1,p,q); q=merge(tr[q].l,tr[q].r); root=merge(merge(p,q),y);} æ“ä½œ 3 ï¼š æŸ¥è¯¢æ’åä¸º i çš„æ•°å’Œæ™®é€šTreapæ˜¯ä¸€æ ·çš„ï¼Œ ä½†æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°è¿”å›çš„æ˜¯ æ’åä¸º i çš„æ•° çš„èŠ‚ç‚¹ç¼–å·kï¼ˆå€¼ä¸ºtr[k].valï¼‰ ã€‚ 12345678910111213141516int getNum(int now,int rk){ while(1) { if(rk&lt;=tr[tr[now].l].size) now=tr[now].l; else { if(rk==tr[tr[now].l].size+1) return now; else { rk-=tr[re[now].l].size+1; now=tr[now].r; } } }} æ“ä½œ 4 ï¼š æŸ¥è¯¢ wei çš„æ’åæŠŠæ€»æ ‘æŒ‰ $wei$ è¿›è¡Œ $spilt$ ï¼Œå¾—åˆ°å·¦éƒ¨åˆ†æ ‘çš„å¤§å°å³ä¸ºrankå€¼ã€‚ 123456int getRank(int wei){ int x,y; spilt(root,wei,x,y); return tr[x].size;} æ“ä½œ 5 ï¼š æ±‚ wei çš„å‰é©±æŠŠæ€»æ ‘æŒ‰ $wei-1$ åˆ†æˆä¸¤ä»½ï¼Œ æ‰€ä»¥å°äº $wei$ çš„èŠ‚ç‚¹éƒ½åœ¨å·¦éƒ¨åˆ†æ ‘ä¸­ï¼Œåªéœ€è¦æ±‚å‡ºå·¦éƒ¨åˆ†æ ‘çš„sizeæ‰€å¯¹åº”çš„èŠ‚ç‚¹çš„å€¼ï¼Œ å°±æ˜¯æ‰€æ±‚çš„ $wei$ çš„å‰é©±ã€‚ 1234567int pre(int wei){ int x,y; spilt(root,wei-1,x,y); return tr[getNum(x,tr[x].size)].val; root=merge(x,y);//å›å¤åŸçŠ¶} æ“ä½œ 6 ï¼š æ±‚ wei çš„åç»§æ‰¾åç»§æ˜¯ç›¸åŒçš„ï¼ŒæŠŠæ€»æ ‘æŒ‰ $wei$ ä¸ºæƒå€¼è°ƒç”¨ $split$ï¼Œæ­¤æ—¶å³éƒ¨åˆ†æ ‘æ’åç¬¬ä¸€çš„æ•°å°±æ˜¯åç»§ 1234567int suc(int wei){ int x,y; spilt(root,wei+1,x,y); return tr[getNum(y,1)].val; root=merge(x,y);//å›å¤åŸçŠ¶} æ“ä½œ 7 ï¼š åè½¬åŒºé—´~~å…ˆå’•ç€ï¼Œæœ‰ç©ºè¡¥~~ æ ¸å¿ƒ 1ï¼š merge æ“ä½œ$merge$ æ“ä½œå³æŒ‰ç…§ FHQ Treap çš„é™„åŠ æƒå€¼~~ç„å­¦~~ç»´æŒå¹³è¡¡å¹¶è¿›è¡Œåˆå¹¶ 1234567891011121314151617int merge(int x,int y)//x æ’&lt; y ,æ‰€ä»¥éœ€è¦ä¿è¯é¡ºåº{ if(!x||!y) return x+y; update(x),update(y); if(tr[x].rnd&lt;tr[y].rnd) { tr[x].r=merge(tr[x].r,y); update(x); return x; } else { tr[y].l=merge(x,tr[y].l); update(y); return y; }} æ ¸å¿ƒ 2ï¼š spilt æ“ä½œ$split$ æ˜¯æŠŠä¸€é¢—Treapåˆ†å¼€ä¸¤ä¸ªæ ‘çš„æ“ä½œã€‚ æœ‰ä¸¤ç§åˆ†æ³•ï¼Œä¸€ç§æ˜¯æŒ‰æƒå€¼åˆ†ï¼Œä¸€ç§æ˜¯æŒ‰$size$ï¼ˆå­æ ‘å¤§å°ï¼‰åˆ†ï¼Œå…·ä½“ç”¨å“ªä¸ªè¦çœ‹æƒ…å†µã€‚ æŒ‰æƒå€¼åˆ† æ³¨æ„è¿™æ—¶å€™æƒå€¼å°äºç­‰äº kçš„èŠ‚ç‚¹éƒ½åœ¨å·¦æ ‘ä¸­ï¼Œå¤§äº kçš„éƒ½åœ¨å³æ ‘ä¸­ ï¼š 12345678910111213void spilt(int now,int val,int &amp;x,int &amp;y){ if(!now) x=y=0; else { if(val&lt;=tr[tr[now].l].val) y=now,spilt(tr[now].l,val,x,tr[now].l); else x=now,spilt(tr[now].r,val,tr[now].r,y); update(now); } } æŒ‰ $size$ åˆ† ï¼š 12345678910111213void spilt(int now,int rnk,int &amp;x,int &amp;y){ if(!now) x=y=0; else { if(rnk&lt;=tr[tr[now].l].size) y=now,spilt(tr[now].l,rnk,x,tr[now].l); else x=now,spilt(tr[now].r,rnk-tr[tr[now].l].size-1,tr[now].r,y); update(now); } } END","link":"/posts/31323/"},{"title":"Segment Tree (PART ONE)","text":"æ¦‚å¿µ çº¿æ®µæ ‘ï¼Œç±»ä¼¼åŒºé—´æ ‘ï¼Œå®ƒåœ¨å„ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€æ¡çº¿æ®µï¼ˆæ•°ç»„ä¸­çš„ä¸€æ®µå­æ•°ç»„ï¼‰ï¼Œä¸»è¦ç”¨äºé«˜æ•ˆè§£å†³è¿ç»­åŒºé—´çš„åŠ¨æ€æŸ¥è¯¢é—®é¢˜ï¼Œç”±äºäºŒå‰ç»“æ„çš„ç‰¹æ€§ï¼Œå®ƒåŸºæœ¬èƒ½ä¿æŒæ¯ä¸ªæ“ä½œçš„å¤æ‚åº¦ä¸º$O(logn)$ã€‚ æ“ä½œä¸‹é¢æˆ‘ä»¬ä»ä¸€ä¸ªç»å…¸çš„ä¾‹å­æ¥äº†è§£çº¿æ®µæ ‘ 12ä»æ•°ç»„arr[0...n-1]ä¸­æŸ¥æ‰¾æŸä¸ªæ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å°å€¼ï¼Œå…¶ä¸­æ•°ç»„å¤§å°å›ºå®šï¼Œä½†æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ çš„å€¼å¯ä»¥éšæ—¶æ›´æ–°ã€‚ æˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šé¢„å¤„ç†è€—æ—¶$O(n)$ï¼ŒæŸ¥è¯¢ã€æ›´æ–°æ“ä½œ$O(logn)$ï¼Œéœ€è¦é¢å¤–çš„ç©ºé—´$O(n)$ã€‚æ ¹æ®è¿™ä¸ªé—®é¢˜æˆ‘ä»¬æ„é€ å¦‚ä¸‹çš„äºŒå‰æ ‘ - å¶å­èŠ‚ç‚¹æ˜¯åŸå§‹ç»„æ•°arrä¸­çš„å…ƒç´  - éå¶å­èŠ‚ç‚¹ä»£è¡¨å®ƒçš„æ‰€æœ‰å­å­™å¶å­èŠ‚ç‚¹æ‰€åœ¨åŒºé—´çš„æœ€å°å€¼ ä¾‹å¦‚å¯¹äºæ•°ç»„[2, 5, 1, 4, 9, 3]å¯ä»¥æ„é€ å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼ˆèƒŒæ™¯ä¸ºç™½è‰²è¡¨ç¤ºå¶å­èŠ‚ç‚¹ï¼Œéå¶å­èŠ‚ç‚¹çš„å€¼æ˜¯å…¶å¯¹åº”æ•°ç»„åŒºé—´å†…çš„æœ€å°å€¼ï¼Œä¾‹å¦‚æ ¹èŠ‚ç‚¹è¡¨ç¤ºæ•°ç»„åŒºé—´arr[0â€¦5]å†…çš„æœ€å°å€¼æ˜¯1ï¼‰ï¼š ç”±äºçº¿æ®µæ ‘çš„çˆ¶èŠ‚ç‚¹åŒºé—´æ˜¯å¹³å‡åˆ†å‰²åˆ°å·¦å³å­æ ‘ï¼Œå› æ­¤çº¿æ®µæ ‘æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œå¯¹äºåŒ…å«$n$ä¸ªå¶å­èŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘ï¼Œå®ƒä¸€å®šæœ‰$n-1$ä¸ªéå¶èŠ‚ç‚¹ï¼Œæ€»å…±$2n-1$ä¸ªèŠ‚ç‚¹ï¼Œå› æ­¤å­˜å‚¨çº¿æ®µæ˜¯éœ€è¦çš„ç©ºé—´å¤æ‚åº¦æ˜¯$O(n)$ åˆ›å»ºçº¿æ®µæ ‘å­èŠ‚ç‚¹æ ¹æ®çº¿æ®µæ ‘çš„æ€§è´¨ï¼ˆå®Œå…¨äºŒå‰æ ‘ï¼‰ï¼Œåªéœ€çŸ¥é“çˆ¶èŠ‚ç‚¹ï¼Œå°±å¯ä»¥è®¡ç®—å‡ºå­èŠ‚ç‚¹çš„åºå· 12345678inline LL getLeftNum(LL p){ return p&lt;&lt;1;}inline LL getRightNum(LL p){ return p&lt;&lt;1|1;} æ ‘çš„å­˜æ”¾å’ŒèŠ‚ç‚¹ä¿¡æ¯é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­æˆ‘ä»¬éœ€è¦ç»´æŠ¤çš„å¯¹è±¡ï¼Œå¯ä»¥æ˜¯ä¸€ä¸ªå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯é¢œè‰²ï¼ŒçŠ¶æ€ç­‰ 1234struct{ int val;//å¯ä»¥æ·»åŠ col,statusï¼Œlztag}Tree[N]; å»ºæ ‘æ“ä½œæˆ‘ä»¬ä½¿ç”¨é€’å½’æ“ä½œæ¥å»ºæ ‘ å½“å·¦ç«¯ç‚¹å’Œå³æ®µç‚¹ç›¸åŒæ—¶ï¼Œæ„å‘³ç€æ­¤æ—¶çš„$p$èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ äºŒåˆ†å½“å‰åŒºé—´ï¼Œé€’å½’å»ºæ ‘ æ³¨æ„ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªå°šæœªå‡ºç°çš„ä¸œè¥¿ï¼Œ$pushup$å‡½æ•°å’Œ$lztag$æ ‡è®° $pushup$å‡½æ•°ç”¨äºä»å­èŠ‚ç‚¹å‘ä¸Šä¾æ¬¡æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å€¼ è€Œ$lztag$æ˜¯ç”¨äºåŒºé—´ä¿®æ”¹çš„æ‡’æ ‡è®° 123456789void buildTree(LL p,LL l,LL r){ lztag[p]=0; if(l==r) {Tree[p]=a[l];return ;} LL mid=(l+r)&gt;&gt;1; buildTree(getLeftNum(p),l,mid); buildTree(getRightNum(p),mid+1,r); pushup(p);} pushup æ“ä½œ$pushup$èµ·åˆ°æ›´æ–°çš„ä½œç”¨ï¼Œå¯¹äºä¸åŒçš„éœ€æ±‚ï¼Œæœ‰ä¸åŒçš„$pushup$æ“ä½œ å¯¹äºæ±‚å’Œï¼Œå¯ä»¥è¿™ä¹ˆå†™ 1234inline void pushup(LL p){ Tree[p]=Tree[getLeftNum(p)]+Tree[getRightNum(p)]);} è€Œå¯¹äºæ±‚ æœ€å¤§å€¼/æœ€å°å€¼ ï¼Œåˆ™å¯ä»¥è¿™ä¹ˆå†™ 12345inline void put_up(LL p){ Tree[p]=max(Tree[getLeftNum(p)],Tree[getRightNum(p)]); //Tree[p]=min(Tree[getLeftNum(p)],Tree[getRightNum(p)]);} æ›´æ–°æ“ä½œæ›´æ–°æ“ä½œå¯ä»¥åˆ†ä¸ºä¸¤ç§ * å•ç‚¹æ“ä½œ * åŒºé—´æ“ä½œ å•ç‚¹æ“ä½œï¼ˆupdataPotï¼‰æ˜ç¡®å˜é‡åï¼š 1. ï¼ˆl ~ rï¼‰ â€”â€” å¯æ”¯é…åŒºé—´ 2. ï¼ˆnedChangeL ~ nedChangeRï¼‰ â€”â€” éœ€æ“ä½œåŒºé—´ 3. mid â€”â€” å¯æ”¯é…åŒºé—´ä¸­ç‚¹ æ³¨ : å½“$mid$ä¸å°äº$nedChangeL$æ—¶ ä»£è¡¨å» $l$ ~ $mid$ æ›´æ–°æ˜¯æœ‰æ„ä¹‰çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬é€‰æ‹©æ›´æ–°è¯¥åŒºé—´ $mid$å’Œ$nedChangeR$åŒç† 12345678void updataPot(LL nedChangeL,LL nedChangeR,LL l,LL r,LL p,LL num){ if(l==r) {Tree[p]=num;return ;} LL mid=(l+r)&gt;&gt;1; if(nedChangeL&lt;=mid) updata(nedChangeL,nedChangeR,l,mid,getLeftNum(p),num); if(nedChangeR&gt;mid) updata(nedChangeL,nedChangeR,mid+1,r,getRightNum(p),num); put_up(p);} åŒºé—´æ“ä½œï¼ˆupdataIntervalï¼‰åŒºé—´æ“ä½œéœ€è¦å¼•å…¥ä¸€ä¸ªæ¦‚å¿µ $lazytag$ : $lazytag$æ ‡æ³¨çš„æ˜¯çº¿æ®µæ ‘ä¸­æ¯ä¸ªæ ‘çš„å˜åŒ–é‡ï¼Œå³ $\\Delta$ $lazytag$ æ“ä½œæ—¶æ­£å¦‚å…¶åï¼Œåªå¯¹ç›®å‰çŠ¶æ€æ‰“ä¸Šæ ‡è®°ï¼Œç­‰åˆ°æ›´æ–°æ—¶ï¼Œæ‰å‘ä¸‹ä¼ é€’ å› æ­¤ï¼Œå¼•å…¥å¦ä¸€ä¸ªå‡½æ•°$pushdown$ï¼Œç”¨äºæ›´æ–°å…¶å­èŠ‚ç‚¹çš„$lazytag$å’Œæœ¬èŠ‚ç‚¹çš„æ•°å€¼ æ¥ä¸‹æ¥ç»™å‡º$pushdown$çš„ä»£ç  123456789101112inline void updataSum(LL p,LL l,LL r,LL num){ lztag[p]=lztag[p]+num; Tree[p]+=num*(r-l+1);}inline void put_down(LL p,LL l,LL r){ LL mid=(l+r)&gt;&gt;1; updataSum(getLeftNum(p),l,mid,lztag[p]); updataSum(getRightNum(p),mid+1,r,lztag[p]); lztag[p]=0;} æœ‰äº†$pushdown$ç®—æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å®Œæˆ$updata$æ“ä½œ 123456789void updataInterval(LL needChangeL,LL needChangeR,LL l,LL r,LL p,LL num){ if(needChangeL&lt;=l&amp;&amp;r&lt;=needChangeR) {updataSum(p,l,r,num);return ;} put_down(p,l,r); LL mid=(l+r)&gt;&gt;1; if(needChangeL&lt;=mid) updata(needChangeL,needChangeR,l,mid,getLeftNum(p),num); if(needChangeR&gt;mid) updata(needChangeL,needChangeR,mid+1,r,getRightNum(p),num); put_up(p);} åŒºé—´æ±‚å€¼ï¼ˆqueryï¼‰åŒºé—´æ±‚å€¼æ—¶ï¼Œæˆ‘ä»¬è¿›è¡Œäº†è¯¢é—®ï¼Œè€Œå› ä¸º$lazytag$çš„åŸå› ï¼Œåœ¨æ±‚å€¼ä¹‹å‰ï¼Œéœ€å…ˆè¿›è¡Œ$pushdown$æ“ä½œ 12345678910LL getSum(LL qx,LL qy,LL l,LL r,LL p){ LL sum=0; if(qx&lt;=l&amp;&amp;r&lt;=qy)return Tree[p]; LL mid=(l+r)&gt;&gt;1; put_down(p,l,r); if(qx&lt;=mid)sum+=getSum(qx,qy,l,mid,getLeftNum(p)); if(qy&gt;mid) sum+=getSum(qx,qy,mid+1,r,getRightNum(p)); return sum;} END","link":"/posts/7674/"},{"title":"ä½è¿ç®—","text":"1.&amp;å¦‚æœä¸¤ä¸ªç›¸åº”çš„äºŒè¿›åˆ¶ä½éƒ½ä¸ºï¼‘ï¼Œåˆ™è¯¥ä½çš„ç»“æœå€¼ä¸º1ï¼›å¦åˆ™ä¸º0ã€‚ æ³¨ï¼šä¸‹é¢éƒ½ç”¨8ä½çš„ unsigned char æ¥åšä¾‹å­ã€‚ &amp;ç®€å•ä¸¾ä¾‹ï¼š1234567811&amp;3 = 3 00001011&amp; 00000011= 00000011 = 3 &amp;æ¯”è¾ƒå®ç”¨çš„ä¾‹å­ï¼šæˆ‘ä»¬ç»å¸¸è¦ç”¨çš„æ˜¯å¦è¢«2æ•´é™¤ï¼Œä¸€èˆ¬éƒ½å†™æˆ if(n % 2 == 0) å¯ä»¥æ¢æˆ if((n&amp;1) == 0) 2.|å¦‚æœä¸¤ä¸ªç›¸åº”çš„äºŒè¿›åˆ¶ä½åªè¦æœ‰ä¸€ä¸ªæ˜¯1ï¼Œç»“æœå°±æ˜¯1ï¼›å¦åˆ™ä¸º0ã€‚ | ç®€å•ä¾‹å­ï¼š12345678911 | 3 = 11 00001011| 00000011= 00001011 = 11 | æ¯”è¾ƒå®ç”¨çš„ä¾‹å­å¯ä»¥ç”¨ä¸€ä¸ªunsigned int æ¥å­˜å‚¨å¤šä¸ªå¸ƒå°”å€¼ã€‚æ¯”å¦‚ä¸€ä¸ªæ–‡ä»¶æœ‰è¯»æƒé™ï¼Œå†™æƒé™ï¼Œæ‰§è¡Œæƒé™ã€‚çœ‹èµ·æ¥è¦è®°å½•3ä¸ªå¸ƒå°”å€¼ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªunsigned intä¹Ÿå¯ä»¥å®Œæˆä»»åŠ¡ã€‚ ä¸€ä¸ªæ•°ræ¥è¡¨ç¤ºè¯»æƒé™ï¼Œå®ƒåªæ›´æ”¹ä¸ªä½æ¥è®°å½•è¯»æƒé™çš„å¸ƒå°”å€¼ 00000001 (è¡¨ç¤ºæœ‰è¯»æƒé™) 00000000 (è¡¨ç¤ºæ²¡æœ‰è¯»æƒé™) ä¸€ä¸ªæ•°wè¡¨ç¤ºå†™æƒé™ï¼Œå®ƒåªç”¨äºŒè¿›åˆ¶çš„å€’æ•°ç¬¬äºŒä½æ¥è®°å½•å¸ƒå°”å€¼ 00000010 (è¡¨ç¤ºæœ‰å†™æƒé™) 00000000 (è¡¨ç¤ºæ²¡æœ‰å†™æƒé™) ä¸€ä¸ªæ•°xè¡¨ç¤ºæ‰§è¡Œæƒé™ï¼Œå®ƒåªç”¨å€’æ•°ç¬¬ä¸‰ä½æ¥è®°å½•å¸ƒå°”å€¼ 00000100 (è¡¨ç¤ºæœ‰æ‰§è¡Œæƒé™) 00000000 (è¡¨ç¤ºæ²¡æœ‰æ‰§è¡Œæƒé™) é‚£ä¹ˆä¸€ä¸ªæ–‡ä»¶åŒæ—¶æ²¡æœ‰3ç§æƒé™å°±æ˜¯ ~r | ~ w | ~ x å³ä¸º 00000000ï¼Œå°±æ˜¯0 åªæœ‰è¯»çš„æƒé™å°±æ˜¯ r | ~w | ~x å³ä¸º 00000001ï¼Œå°±æ˜¯1 åªæœ‰å†™çš„æƒé™å°±æ˜¯ ~r | w | ~x å³ä¸º 00000010ï¼Œå°±æ˜¯2 ä¸€ä¸ªæ–‡ä»¶åŒæ—¶æœ‰3ç§æƒé™å°±æ˜¯ r | w | x å³ä¸º 00000111ï¼Œå°±æ˜¯7 3. &lt;&lt; å‘å·¦ç§»ä½ç§»&lt;&lt;ç®€å•ä¾‹å­(å‘å·¦ç§»ä¸€ä½ï¼Œå³è¾¹è‡ªåŠ¨è¡¥0)11 &lt;&lt; 1 = 22 00001011 &lt;&lt; 1 00010110 = 22 ç›¸å½“äºäºŒè¿›åˆ¶çš„æ¯ä¸ªæ•°éƒ½å˜æˆå½“å‰å€¼çš„ä¸¤å€ï¼Œç»“æœå°±æ˜¯å˜æˆå½“å‰å€¼çš„ä¸¤å€ã€‚ n * 2 == (n &lt;&lt; 1) 4. &gt;&gt; å‘å³ä½ç§»&gt;&gt;ç®€å•ä¾‹å­(å‘å³ç§»ä¸€ä½ï¼Œå·¦è¾¹è‡ªåŠ¨è¡¥1)1234511 &gt;&gt; 1 = 500001011 &gt;&gt; 100000101 = 5 æ³¨æ„åˆ°æœ€åä¸€ä½çš„1è¢«å¹²æ‰äº†ã€‚ æ¯”è¾ƒå®ç”¨çš„ä¾‹å­æ˜¯: int n = n / 2 ç­‰ä»·äº int n = n &gt;&gt; 1 ç­‰ä»·äº int n &gt;&gt;= 1 5. ^ å¼‚æˆ–ä¸¤ä¸ªç›¸åŒçš„æ•°ä¼šå˜æˆ0ï¼Œåä¹‹æ˜¯1 123456711^3 = 8 00001011^ 00000011= 00001000 = 8 Given an array of integers, every element appearstwice except for one. Fnd that single one. åœ¨ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œæ‰€æœ‰æ•°å­—éƒ½å‡ºç°äº†ä¸¤æ¬¡ï¼Œåªæœ‰ä¸€ä¸ªæ²¡æœ‰ å¼‚æˆ–æ˜¯å«‰å¦’æˆåŒæˆå¯¹çš„ã€‚ æ¯”å¦‚ int t = {1,2,3,3,2,1,5} è¦æ‰¾åˆ°5ã€‚ ç”¨å¼‚æˆ–å°±å®Œç¾äº†ï¼Œæ‰€æœ‰ç›¸åŒçš„éƒ½ä¼šæ¶ˆå¤±ï¼Œç•™ä¸‹æ¥çš„å°±æ˜¯5äº†ã€‚ 12345678intsingleNumber(int A[], int n){ for(int i = 1; i &lt; n; ++i) { A[0] ^= A[i]; } return A[0]; } è¿˜æœ‰å°±æ˜¯ç”¨ä¸tmpå€¼æ¥äº¤æ¢ä¸¤ä¸ªæ•° 1234567//ä¸ç”¨tempäº¤æ¢ä¸¤ä¸ªæ•´æ•°voidswap(int&amp; x , int&amp; y){ x ^= y; y ^= x; x ^= y;} 6.~è¿™ä¸ªåœ¨åŠ æ³•ä¸­ç”¨åˆ° x-y = x + ~y + 1 æ‰€ä»¥~y = - y -1 æ¯”å¦‚ ~11 = -11 -1 = -12 7.%(å¿«é€Ÿå–æ¨¡)æ±‚ 100 % 8çš„ ä¼˜åŒ–è§£æ³•ã€‚ æˆ‘ä»¬çŸ¥é“8åˆšå¥½æ˜¯2çš„3æ¬¡æ–¹ï¼Œ æ‰€ä»¥ 100 % 8 == 100 - math.floor(100 / 8) * 8 == 100 - ((100 &gt;&gt; 3) &lt;&lt; 3)ã€‚","link":"/posts/60366/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/posts/1243066710/"},{"title":"è‹±è¯­è¯­æ³•","text":"éè°“è¯­åŠ¨è¯éè°“è¯­åŠ¨è¯åœ¨å¥å­ä¸­ç”¨äºå®šè¯­ï¼Œè¡¨è¯­ï¼Œè¡¥è¯­ å¸¸è§å½¢å¼å¦‚ä¸‹ï¼š | åŠ¨è¯å½¢å¼ | è¯­æ€ | æ—¶é—´èŒƒå›´ | é€šå¸¸æ„ä¹‰ | æ˜¯å¦å¯ä½œä¸»è¯­ | | :â€”â€”â€”-: | :â€“: | :â€”â€”-: | :â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”: | :â€”â€”â€”-: | | doing | ä¸»åŠ¨ | ä¸€èˆ¬ | è¡¨ç¤ºä¸€ä¸ªé€šå¸¸çš„åŠ¨ä½œ | âˆš | | done | è¢«åŠ¨ | å®Œæˆ | è¡¨è¢«åŠ¨ï¼Œå·²ç»è¢«å®Œæˆ | Ã— | | to do | ä¸»åŠ¨ | ä¸€èˆ¬ | è¡¨ç›®çš„ï¼Œå»å‘ï¼Œæ„å›¾ï¼Œå…·ä½“çš„ä¸€æ¬¡åŠ¨ä½œ | âˆš | | having done | ä¸»åŠ¨ | å®Œæˆ | å½“åŠ¨ä½œæœ‰å…ˆåå¸¸ç”¨ï¼Œæ³¨æ„ä¸doneåŒºåˆ† | âˆš | | being done | è¢«åŠ¨ | å®Œæˆ/è¿›è¡Œ | å¯è¡¨ç¤ºæ­£åœ¨è¢«å®Œæˆ/è¿›è¡Œï¼Œæ³¨æ„ä¸doneåŒºåˆ† | âˆš | | to be done | è¢«åŠ¨ | å°†æ¥ | å¯è¡¨ç¤ºå°†è¦è¢«â€¦ï¼Œæ³¨æ„ä¸doneåŒºåˆ† | âˆš | | to have done | ä¸»åŠ¨ | å°†æ¥å®Œæˆ | è¡¨å°†è¦å®Œæˆ..ï¼Œæ³¨æ„ä¸doneåŒºåˆ† | âˆš | e.g. doing Tom stood thereï¼Œwondering what he could do for the poor man sitting beside himï¼ done Dr. Lee was very happy to see his mother taken good care of at home. to do To catch the early flight,we ordered a taxi in advance and got up very early. having done Having worked for two days, Steve managed to finish his report on schedule. being done The meeting being held now is of great importance. to be done I have a car to be repaired. to have done You are lucky to have got a ticket.","link":"/posts/683983/"},{"title":"bitsetè®²è§£","text":"ä¸ºäº†å†™ä¸€é“æ¯’ç˜¤é¢˜ï¼Œå†³å®šå­¦ä¸€ä¸‹ bitset å¤´æ–‡ä»¶ #include&lt;bitset&gt; åŒæ—¶éœ€è¦å‘½åç©ºé—´ std å®šä¹‰12bitset &lt;N&gt; bs// é»˜è®¤çš„æ„é€ å‡½æ•°å°†å…¶åˆå§‹ä¸ºå…¨0 æœ‰ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„åœ°æ–¹ï¼Œbitset çš„ $bs[0]$ æ˜¯æœ€åä¸€ä½ï¼Œè€Œ $bs[N-1]$ æ˜¯ç¬¬ä¸€ä½ 123std::bitset&lt;8&gt; bs;//bs[0] = 1; // 0000 0001//bs[7] = 1; // 1000 0000 æ„é€ å‡½æ•°12345678910std::bitset&lt;8&gt; bs(7); // 0000 0111std::bitset&lt;8&gt; bs(0x07); // 0000 0111bitset&lt;numeric_limits&lt;unsigned short&gt;::digits&gt; bs1(267); // 16ä½ bitset&lt;numeric_limits&lt;unsigned long&gt;::digits&gt; bs2(267); // 32ä½std::bitset&lt;8&gt; bs(\"00000111\"); // 7 æ“ä½œ|æˆå‘˜å‡½æ•° | åŠŸèƒ½| | â€”â€” | â€”â€” | | bs.any() | æ˜¯å¦å­˜åœ¨å€¼ä¸º 1 çš„äºŒè¿›åˆ¶ä½ | | bs.none() | æ˜¯å¦ä¸å­˜åœ¨å€¼ä¸º 1 çš„äºŒè¿›åˆ¶ä½ æˆ–è€…è¯´æ˜¯å¦å…¨éƒ¨ä½ä¸º 0 | | bs.size() | ä½é•¿ï¼Œä¹Ÿå³æ˜¯éæ¨¡æ¿å‚æ•°å€¼ | | bs.count() | å€¼ä¸º 1 çš„ä¸ªæ•° | | bs.test(pos) | æµ‹è¯• pos å¤„çš„äºŒè¿›åˆ¶ä½æ˜¯å¦ä¸º 1 è¿”å›å’Œ0åšæˆ–è¿ç®—çš„å€¼ | | bs.set() | å…¨éƒ¨ä½ç½®é‡ç½®ä¸º 1 | | bs.set(pos) | pos ä½çš„äºŒè¿›åˆ¶ä½ç½®ä¸ 1 åšæˆ–è¿ç®— | | bs.reset() | å…¨éƒ¨ä½ç½®é‡ç½®ä¸º 0 | | bs.reset(pos) | pos ä½çš„äºŒè¿›åˆ¶ä½ç½®ä¸ 0 åšæˆ–è¿ç®— | | bs.flip() | å…¨éƒ¨ä½é€ä½å–å | | bs.flip(pos) | poså¤„çš„äºŒè¿›åˆ¶ä½å–å | | bs.to_ulong() | å°†äºŒè¿›åˆ¶è½¬æ¢ä¸ºunsigned longè¾“å‡º | | bs.to_string() | å°†äºŒè¿›åˆ¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¾“å‡º | | ~bs | æŒ‰ä½å–å æ•ˆæœç­‰æ•ˆä¸º bs.flip() | | os &lt;&lt; b | å°†äºŒè¿›åˆ¶ä½è¾“å‡ºåˆ°osæµ å°å€¼åœ¨å³ï¼Œå¤§å€¼åœ¨å·¦ | è¿ç®—bitset çš„è¿ç®—å°±åƒä¸€ä¸ªæ™®é€šçš„æ•´æ•°ä¸€æ ·ï¼Œå¯ä»¥è¿›è¡Œ ä¸ ( &amp; ) ã€æˆ– ( | ) ã€ å¼‚æˆ– ( ^ )ã€ å·¦ç§» ( &lt;&lt; ) ã€ å³ç§» ( &gt;&gt; ) ç­‰æ“ä½œã€‚ 1234567891011121314151617181920bitset&lt;4&gt; foo (std::string(\"1001\"));bitset&lt;4&gt; bar (std::string(\"0011\"));cout &lt;&lt; (foo^=bar) &lt;&lt; '\\n'; // 1010 (XOR,assign)cout &lt;&lt; (foo&amp;=bar) &lt;&lt; '\\n'; // 0010 (AND,assign)cout &lt;&lt; (foo|=bar) &lt;&lt; '\\n'; // 0011 (OR,assign)cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; '\\n'; // 1100 (SHL,assign)cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; '\\n'; // 0110 (SHR,assign)cout &lt;&lt; (~bar) &lt;&lt; '\\n'; // 1100 (NOT)cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; '\\n'; // 0110 (SHL)cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; '\\n'; // 0001 (SHR)cout &lt;&lt; (foo==bar) &lt;&lt; '\\n'; // false (0110==0011)cout &lt;&lt; (foo!=bar) &lt;&lt; '\\n'; // true (0110!=0011)cout &lt;&lt; (foo&amp;bar) &lt;&lt; '\\n'; // 0010cout &lt;&lt; (foo|bar) &lt;&lt; '\\n'; // 0111cout &lt;&lt; (foo^bar) &lt;&lt; '\\n'; // 0101 å‚è€ƒèµ„æ–™ C++ Reference CSDN by Inside_Zhang èƒ¡å°å…”çš„OIåšå®¢","link":"/posts/36423/"},{"title":"è«é˜Ÿ","text":"æˆ‘ä»¬ä½¿ç”¨ä¸€é“ä¾‹é¢˜æ¥å¸®åŠ©æˆ‘ä»¬ç†è§£è«é˜Ÿç®—æ³• æ´›è°·P1972 ä¾‹é¢˜é¢˜ç›®æè¿°:HH æœ‰ä¸€ä¸²ç”±å„ç§æ¼‚äº®çš„è´å£³ç»„æˆçš„é¡¹é“¾ã€‚HH ç›¸ä¿¡ä¸åŒçš„è´å£³ä¼šå¸¦æ¥å¥½è¿ï¼Œæ‰€ä»¥æ¯æ¬¡æ•£æ­¥å®Œåï¼Œ ä»–éƒ½ä¼šéšæ„å–å‡ºä¸€æ®µè´å£³ï¼Œæ€è€ƒå®ƒä»¬æ‰€è¡¨è¾¾çš„å«ä¹‰ã€‚HH ä¸æ–­åœ°æ”¶é›†æ–°çš„è´å£³ï¼Œå› æ­¤ï¼Œ ä»–çš„é¡¹é“¾å˜å¾—è¶Šæ¥è¶Šé•¿ã€‚æœ‰ä¸€å¤©ï¼Œä»–çªç„¶æå‡ºäº†ä¸€ä¸ªé—®é¢˜ï¼šæŸä¸€æ®µè´å£³ä¸­ï¼ŒåŒ…å«äº†å¤šå°‘ç§ä¸åŒçš„è´å£³ï¼Ÿ è¿™ä¸ªé—®é¢˜å¾ˆéš¾å›ç­”â€¦â€¦å› ä¸ºé¡¹é“¾å®åœ¨æ˜¯å¤ªé•¿äº†ã€‚äºæ˜¯ï¼Œä»–åªå¥½æ±‚åŠ©ç¿æ™ºçš„ä½ æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ è¾“å…¥è¾“å‡ºæ ¼å¼:è¾“å…¥æ ¼å¼ï¼šç¬¬ä¸€è¡Œï¼šä¸€ä¸ªæ•´æ•°Nï¼Œè¡¨ç¤ºé¡¹é“¾çš„é•¿åº¦ã€‚ ç¬¬äºŒè¡Œï¼šN ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä¾æ¬¡è¡¨ç¤ºé¡¹é“¾ä¸­è´å£³çš„ç¼–å·ï¼ˆç¼–å·ä¸º0 åˆ°1000000 ä¹‹é—´çš„æ•´æ•°ï¼‰ã€‚ ç¬¬ä¸‰è¡Œï¼šä¸€ä¸ªæ•´æ•°Mï¼Œè¡¨ç¤ºHH è¯¢é—®çš„ä¸ªæ•°ã€‚ æ¥ä¸‹æ¥M è¡Œï¼šæ¯è¡Œä¸¤ä¸ªæ•´æ•°ï¼ŒL å’ŒRï¼ˆ1 â‰¤ L â‰¤ R â‰¤ Nï¼‰ï¼Œè¡¨ç¤ºè¯¢é—®çš„åŒºé—´ã€‚ è¾“å‡ºæ ¼å¼ï¼šM è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œä¾æ¬¡è¡¨ç¤ºè¯¢é—®å¯¹åº”çš„ç­”æ¡ˆã€‚ è¾“å…¥è¾“å‡ºæ ·ä¾‹è¾“å…¥æ ·ä¾‹#1:12345661 2 3 4 3 531 23 52 6 è¾“å‡ºæ ·ä¾‹#1ï¼š123224 å¼•å…¥æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœç”¨æš´åŠ›ç®—æ³•è¿›è¡Œæ±‚è§£çš„è¯ï¼Œæˆ‘ä»¬ä¼šé€‰æ‹©å¼€ä¸€ä¸ª$cnt$æ•°ç»„ï¼Œéå†åŒºé—´ï¼Œç´¯åŠ æ±‚è§£ï¼Œ æ˜¾ç„¶ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦å¤ªé«˜ï¼Œè‚¯å®šä¼šçˆ†æ‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è«é˜Ÿç®—æ³• é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ$curl$ï¼Œ$curr$ï¼Œæ¯æ¬¡è¯¢é—®æˆ‘ä»¬é€šè¿‡ç§»åŠ¨è¿™ä¸¤ä¸ªæŒ‡é’ˆæ¥æ¡†å®šåŒºé—´ï¼Œ å‡è®¾ä¸€å¼€å§‹ $curl$ æŒ‡å‘ $4$ ï¼Œ$curr$ æŒ‡å‘ $6$ï¼Œ ä¸‹ä¸€ä¸ªè¯¢é—®è¦æ±‚åŒºé—´ $3$ ~ $5$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ $curlâ€“$ ï¼Œé¡ºå¸¦æ’å…¥ $3$ ï¼Œ$currâ€“$ï¼Œé¡ºå¸¦åˆ å» $6$ï¼Œ æ³¨æ„å½“å‰çš„å…ˆåé¡ºåº $curlâ€“$ è¦æ±‚å…ˆå‡ååŠ å…¥ï¼Œè€Œ $currâ€“$ è¦æ±‚å…ˆåˆ å»å†å‡ åŒç†ï¼Œ$curl++$ è¦æ±‚å…ˆåˆ å»å†åŠ ï¼Œè€Œ $curr++$ è¦æ±‚å…ˆåŠ å†åŠ å…¥ æˆ‘ä»¬å¯ä»¥å†™å‡ºè¿™ä¸€éƒ¨åˆ† 123456789int lsans;//è¡¨ç¤ºè¯¥åŒºé—´çš„ç­”æ¡ˆinline void add(int pos){lsans+=(++cnt[a[pos]]==1);}//åŠ å…¥inline void del(int pos){lsans-=(--cnt[a[pos]]==0);}//åˆ å»while(curr&lt;rr) add(++curr);//å˜åŒ–èŒƒå›´while(curr&gt;rr) del(curr--);while(curl&gt;ll) add(--curl);while(curl&lt;ll) del(curl++); è«é˜Ÿçš„ä¼˜åŒ–æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“çš„å‘ç°ï¼Œå¦‚æœé¢å¯¹ç‰¹åˆ«è®¾è®¡çš„æ•°æ®ï¼Œä¸Šé¢çš„æ—¶é—´å¤æ‚åº¦ä»ç„¶å¾ˆé«˜ ä¸¾ä¸ªæ —å­ï¼Œæœ‰6ä¸ªè¯¢é—®å¦‚ä¸‹ï¼š 1(1, 100) (2, 2) (3, 99) (4, 4) (5, 102) (6, 7) æˆ‘ä»¬å¦‚æœç›´æ¥æŒ‰å·¦ç«¯ç‚¹ä¸Šå‡æ’åºï¼Œ ç”¨ä¸Šè¿°æ–¹æ³•å¤„ç†æ—¶ï¼Œå·¦ç«¯ç‚¹ä¼šç§»åŠ¨$6$æ¬¡ï¼Œå³ç«¯ç‚¹ä¼šç§»åŠ¨ç§»åŠ¨$98+97+95+98+95=483$æ¬¡ã€‚ æˆ‘ä»¬å¯ä»¥å…ˆæŒ‰å·¦ç«¯ç‚¹ä¸Šå‡æ’åºï¼Œå¦‚æœå·¦ç«¯ç‚¹æ‰€åœ¨çš„å—ç›¸åŒï¼Œå†åœ¨å—å†…æŒ‰å³ç«¯ç‚¹ä¸Šå‡æ’åºï¼Œå¾—åˆ°ç»“æœå°±åƒè¿™æ · 1(2, 2) (4, 4) (6, 7) (5, 102) (3, 99) (1, 100) å·¦ç«¯ç‚¹ç§»åŠ¨æ¬¡æ•°ä¸º$2+2+1+2+2=9$æ¬¡ï¼Œæ¯”åŸæ¥ç¨å¤šã€‚å³ç«¯ç‚¹ç§»åŠ¨æ¬¡æ•°ä¸º$2+3+95+3+1=104$ï¼Œå³ç«¯ç‚¹çš„ç§»åŠ¨æ¬¡æ•°å¤§å¤§é™ä½äº†ã€‚ $Code$ï¼š123456789struct ques{ int l , r , id ;}que[100005];bool cmp(const ques &amp;a,const ques &amp;b) { return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;} æœ€ç»ˆçš„ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;#define sync_with_stdio(false)using namespace std;inline int read(){ int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')w=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;}struct ques{ int l , r , id ;}que[100005];int n,m, blo,lsans;bool cmp(const ques &amp;a,const ques &amp;b) {return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;}int a[100005],cnt[1000005],ans[100005];inline void add(int pos){lsans+=(++cnt[a[pos]]==1);}inline void del(int pos){lsans-=(--cnt[a[pos]]==0);}int main(){ n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); m=read();blo=sqrt(m); for(int i=1;i&lt;=m;i++) { que[i].l=read(),que[i].r=read(); que[i].id=i; } sort(que+1,que+m+1,cmp); int curl=0,curr=0; for(int i=1;i&lt;=m;i++) { int ll=que[i].l,rr=que[i].r,idd=que[i].id; while(curr&lt;rr) add(++curr); while(curr&gt;rr) del(curr--); while(curl&gt;ll) add(--curl); while(curl&lt;ll) del(curl++); ans[idd]=lsans; } for(int i=1;i&lt;=m;i++) printf(\"%d\\n\", ans[i]);}","link":"/posts/20389/"},{"title":"æ•°è®º","text":"åˆå¼€äº†ä¸€ä¸ªä¸§å¿ƒç—…ç‹‚çš„å¤§å‘ï¼Œ~~å‡ ä¸ªæœˆéƒ½æ‰“ä¸å®Œ~~ï¼Œå¸Œæœ›noipå‰å¯ä»¥æ‰“çš„å®Œå§~~ï¼ˆåˆæ˜¯ä¸€ä¸ªflagï¼‰~~ æœ€å¤§å…¬çº¦æ•°ï¼ˆGCDï¼‰ä¸€èˆ¬ä½¿ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼ˆè¾—è½¬ç›¸é™¤æ³•ï¼‰æ±‚æœ€å¤§å…¬çº¦æ•°ï¼Œä½†åœ¨é«˜ç²¾æƒ…å†µä¸‹ï¼Œ%è¿ç®—è¿‡æ…¢ï¼Œæˆ‘ä»¬ä½¿ç”¨æ›´ç›¸æŸå‡æœ¯æ¥ä»£æ›¿ 12345int gcd(int x,int y)//è¾—è½¬ç›¸é™¤æ³•{ if(y==0) return x; return gcd(y,x%y);} 123456789int gcd(int a,int b)//æ›´ç›¸æŸå‡æœ¯{ while(a!=b) { if(a&gt;b) a-=b; else b-=a; } return a;} æœ€å°å…¬å€æ•°ï¼ˆLCMï¼‰æ±‚ä¸¤ä¸ªæ•° $x$ï¼Œ$y$ çš„æœ€å°å…¬å€æ•°ï¼Œæ˜“å¾— $lcm(x,y)=\\frac {x*y}{gcd(x,y)}$ ç´ æ•°æš´åŠ›æ±‚è§£æ²¡å•¥å¥½è¯´çš„ã€‚ã€‚ã€‚æ—¶é—´å¤æ‚åº¦ $O(n^2)$ 123456bool is_prime(int x){ for(int i=2;i&lt;=sqrt(x);i++) if(x%i==0) return 0; return 1;} Eratosthenesç­›æ³•ï¼ˆåŸƒæ°ç­›ï¼‰æˆ‘ä»¬å€’ç€æ¥æƒ³ï¼Œå› ä¸ºä¸€ä¸ªæ•°çš„å€æ•°ä¸å¯èƒ½æ˜¯è´¨æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä» $2$ å¼€å§‹å¾€ä¸Šç­›ï¼Œå‘ç°ä¸€ä¸ªæ•°æ²¡æœ‰è¢«æ ‡è®°è¿‡ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°è‚¯å®šå°±æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œå†æŠŠå®ƒçš„å€æ•°æ‰“ä¸ªæ ‡è®°ï¼Œæ—¶é—´å¤æ‚åº¦ $O(nloglogn)$ 1234567891011121314//æ±‚1~nçš„æ‰€æœ‰è´¨æ•°bool prime[10000000+5];int n;void get_prime(int n){ int i, j; for (i=1;i&lt;=n;i++) prime[i]=1; prime[1]=0; for (i=2; i&lt;=n; i++) { if (!prime[i]) continue; for (j=i*2;j&lt;=n;j+=i) prime[j]=0; }} Eulerç­›æ³•ï¼ˆæ¬§æ‹‰ç­›ï¼‰æ¬§æ‹‰ç­›æ˜¯åŸƒæ°ç­›çš„ä¼˜åŒ–ï¼Œåœ¨åŸƒæ°ç­›çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æœ‰ä¸€äº›æ•°è¢«ç­›äº†å¤šæ¬¡ï¼Œä¾‹å¦‚ $6$ ,åœ¨ $2$ å’Œ $3$ çš„æ—¶å€™éƒ½è¢«ç­›äº†ä¸€æ¬¡ï¼Œå‡å¦‚æˆ‘ä»¬å¯ä»¥é¿å…è¿™äº›é‡å¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥åšåˆ° $O(n)$ çš„æ—¶é—´å¤æ‚åº¦ï¼Œå…ˆç»™å‡ºä»£ç  12345678910111213141516//æ±‚1~nçš„æ‰€æœ‰è´¨æ•°int prime[10000000+5],ntpri[10000000+5],tot;int n;void get_prime(){ ntpri[1]=1; for(int i=2;i&lt;=n;i++) { if(!ntpri[i]) pri[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;j++) { ntpri[pri[j]*i]=1; if(i%pri[j]==0) break;//å…³é”® } }} è¿™å¥ if(i%pri[j]==0) break; æ˜¯å…³é”®æ‰€åœ¨ å‡è®¾æˆ‘ä»¬ç­›åˆ°äº†ç¬¬ $i$ ä¸ªæ•°ï¼Œå¾ªç¯åˆ° $prime[j]$ ï¼Œ å¦‚æœ $prime[j]|i$ ï¼Œé‚£ä¹ˆå¿…å®šæœ‰ä¸€ä¸ªæ•° $x$ ï¼Œä½¿å¾— $i=x \\cdot prime[j]$ ï¼Œ é‚£ä¹ˆå¦‚æœä¸‹ä¸€ä¸ªæ•° $prime[j+1]$ å’Œ $i$ ç›¸ä¹˜ï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ªæ•° $p$ ï¼Œ è€Œ $p=prime[j+1] \\cdot i=prime[j+1] \\cdot x \\cdot prime[j]=k*prime[j]$ è®¾ $k=prime[j+1] \\cdot x$ ï¼Œ å³ $prime[j+1] \\cdot i=k \\cdot prime[j]$ æ‰€ä»¥åœ¨æœªæ¥ä¸€å®šæœ‰ä¸€ä¸ªæ•°ä¹˜ä»¥ $prime[j]$ æ°å¥½å¯ä»¥æŠŠ $p$ ç­›æ‰ï¼Œä¸å¿…è¦å†åˆ° $prime[j+1]$ ç­›è¿™ä¸ªæ•° Miller Rabinç®—æ³•Miller Rabin æ˜¯ä¾æ®äºè´¹é©¬å°å®šç†çš„ä¸€ä¸ª éšæœºç®—æ³• ï¼Œå…ˆä»‹ç»è´¹é©¬å°å®šç† $$ a^{P-1}\\equiv 1(modP) $$ å…¶ä¸­ $P$ ä¸ºè´¨æ•°ï¼Œä¸” $gcd(a,P)=1$ ï¼Œ å‡å¦‚æœ‰ä¸€ä¸ªæ•° $P$ å¯¹äºä»»ä½• $a$ æ»¡è¶³è¯¥æ€§è´¨ï¼Œé‚£ä¹ˆ $P$ æ˜¯ä¸æ˜¯å°±æ˜¯è´¨æ•°å‘¢ï¼Ÿ ç„¶è€Œè¿™æ˜¯é”™è¯¯çš„ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª~~ä¸“é—¨é’ˆå¯¹å®ƒ~~çš„åä¾‹ï¼š å¡è¿ˆå…‹å°”æ•°ï¼ˆCarmichaelæ•°ï¼‰ å¡è¿ˆå…‹å°”æ•°çš„å®šä¹‰æ˜¯å¯¹äºåˆæ•° $n$ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰æ­£æ•´æ•° $b$ï¼Œ$b$ å’Œ $n$ äº’ç´ ï¼Œ éƒ½æœ‰åŒä½™å¼ $b^{N-1}â‰¡ 1 (mod N)$ æˆç«‹ï¼Œåˆ™åˆæ•° $n$ ä¸ºCarmichaelæ•°ã€‚ ä½†æ˜¯æˆ‘ä»¬ä»»ç„¶å¯ä»¥é€šè¿‡è´¹é©¬å°å®šç†æ¥æ±‚ç´ æ•°ï¼Œæ¯•ç«Ÿ100000000ä»¥å†…åªæœ‰255ä¸ªå¡ç±³åˆ‡å°”æ•°ï¼Œ åªè¦æˆ‘ä»¬å¤šæ¬¡è®¡ç®—ï¼Œä»»ç„¶å¯ä»¥ä¿è¯ 99.9% ä»¥ä¸Šçš„æ­£ç¡®ç‡ï¼Œ ~~ä½†å®ƒè¿˜æ˜¯ä¸ªç„å­¦ç®—æ³•ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥èƒŒä¸‹ä¸€äº›intä»¥å†…æ‰€æœ‰å¡è¿ˆå…‹å°”æ•°~~ ï¼Œ ~~å…ˆå’•å’•å’•~~ çŸ©é˜µçŸ©é˜µä¹˜æ³•ä¸¾ä¸ªæ —å­ï¼ˆæ¥è‡ªç™¾åº¦ç™¾ç§‘ï¼‰ è®¾ $A$ ä¸º $n \\times k$ é˜¶çš„çŸ©é˜µ ï¼Œ$B$ ä¸º $k \\times m$ é˜¶çš„çŸ©é˜µ åˆ™ $C=A \\cdot B$ å¯ä»¥è¡¨ç¤ºä¸º $C_{i,j}=\\sum_{p=1}^{k}A_{i,p} \\times B_{p,j}$ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int a[105][105];int b[105][105];int c[105][105];int main() { int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) for(int t=1;t&lt;=m;t++) cin&gt;&gt;a[i][t]; for(int i=1;i&lt;=m;i++) for(int t=1;t&lt;=k;t++) cin&gt;&gt;b[i][t]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) for(int t=1;t&lt;=m;t++) c[i][j]+=a[i][t]*b[t][j]; for(int i=1;i&lt;=n;i++) { for(int t=1;t&lt;=k;t++) cout&lt;&lt;c[i][t]&lt;&lt;' '; puts(\"\"); }} çŸ©é˜µå¿«é€Ÿå¹‚å…ˆè®² å¿«é€Ÿå¹‚ï¼Œè¿˜æ˜¯åˆ©ç”¨äºŒè¿›åˆ¶çš„æ€æƒ³ 12345678910111213//æ±‚xçš„kæ¬¡æ–¹typedef long long LL;LL fastpow(LL x,LL k)ï½› LL ans=1; while(k) { if(k&amp;1) ans*=x; x*=x; k&gt;&gt;=1; } return ans;ï½ çŸ©é˜µå¿«é€Ÿå¹‚å°±æ˜¯æŠŠä¹˜æ¢æˆçŸ©é˜µä¹˜QWQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL M=1e9+7;struct data { LL matrix[105][105];};data a,eans;LL n,k;data mul(data a,data b) { data ans; memset(ans.matrix,0,sizeof(ans.matrix)); for(int i=1; i&lt;=n; ++i) { for(int k=1; k&lt;=n; ++k) { for(int t=1; t&lt;=n; ++t) { ans.matrix[i][k]=ans.matrix[i][k]%M+a.matrix[i][t]*b.matrix[t][k]%M; } } } return ans;}data fastpow(data a,LL b) { data ans; for(int i=1; i&lt;=n; ++i) ans.matrix[i][i]=1; while(b!=0) { if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b&gt;&gt;=1; } return ans;}int main() {// freopen(\"testdata (1).in\",\"r\",stdin);// freopen(\"1.txt\",\"w\",stdout); cin&gt;&gt;n&gt;&gt;k; for(int i=1; i&lt;=n; ++i) for(int k=1; k&lt;=n; ++k) cin&gt;&gt;a.matrix[i][k]; eans=fastpow(a,k); for(int i=1; i&lt;=n; ++i) { for(int k=1; k&lt;=n; ++k) cout&lt;&lt;eans.matrix[i][k]%M&lt;&lt;' '; cout&lt;&lt;endl; }} çŸ©é˜µåŠ é€Ÿ ~~å’•å’•å’•~~ é€†å…ƒè´¹é©¬å°å®šç†EXGCDçº¿æ€§æ±‚é€†å…ƒè®¡ç®—ç›¸å…³é«˜æ–¯æ¶ˆå…ƒBSGSç®—æ³•é«˜ç²¾FFTNTTç»„åˆæ•°å­¦lucaså®šç†Burnsideå¼•ç†Polyaå®šç†ç¾¤ç½®æ¢ç¾¤åŠè½®æ¢åæ¼”ç§¯æ€§å‡½æ•°æ¬§æ‹‰å‡½æ•°è«æ¯”ä¹Œæ–¯å‡½æ•°åŸæ ¹å·ç§¯è«æ¯”ä¹Œæ–¯åæ¼”æœæ•™ç­›æ´²é˜ç­›æ‚é¡¹è£´èœ€å®šç†æ¬§æ‹‰å®šç†ä¸­å›½å‰©ä½™å®šç†","link":"/posts/15425/"},{"title":"æœ€å°ç”Ÿæˆæ ‘","text":"æœ€å°ç”Ÿæˆæ ‘æœ‰ä¸¤ç§ç®—æ³• Prim &amp; Kruskal 1. Prim1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define inf 0x7fffffff#define maxn 5005int cost[maxn][maxn],minn,n,m,v2[maxn],tot=1,now,ans;bool v1[maxn];inline void getcost(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { cost[i][j]=inf; } } for(int i=1,u,v,w; i&lt;=m; i++) { scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); if(cost[u][v]&gt;w) { cost[u][v]=cost[v][u]=w; } }//åˆå§‹åŒ–costæ•°ç»„ for(int i=1; i&lt;=n; i++) { v2[i]=cost[1][i]; } v1[1]=1;//æ‰¾å‡ºä¸1èŠ‚ç‚¹ç›¸è¿çš„è¾¹å¹¶è¿›è¡Œæ ‡è®°}inline int prim(){ while(tot&lt;n) { //æœ€å°ç”Ÿæˆæ ‘çš„æ¦‚å¿µ minn=inf; tot++; for(int i=1; i&lt;=n; i++) { if(!v1[i]&amp;&amp;v2[i]&lt;minn) { minn=v2[i]; now=i; } }//æ‰¾å‡ºæœ€å°è¾¹ ans+=minn;//æ›´æ–°ç­”æ¡ˆ for(int i=1; i&lt;=n; i++) { if(v2[i]&gt;cost[now][i]&amp;&amp;!v1[i]) { v2[i]=cost[now][i]; } } v1[now]=1;//åœ¨æ‰¾å‡ºä¸nowèŠ‚ç‚¹ç›¸è¿çš„è¾¹å¹¶è¿›è¡Œæ ‡è®° } return ans;}int main(){ getcost(); printf(\"%d\",prim()); return 0;//ä¸»å‡½æ•°ä¸è§£é‡Š} 2. Kruskal1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define max(a,b) return a&gt;b?a:b using namespace std;struct Edge{int pointA,pointB,w;}edge[200005];int father[5005],n,m,ans,eu,ev,cnt;inline bool cmp(Edge a,Edge b){return a.w&lt;b.w;}//å¿«æ’çš„ä¾æ®inline int findfather(int x){ while(x!=father[x]) x=father[x]=father[father[x]]; return x;}//å¹¶æŸ¥é›†æ¨¡æ¿ï¼Œç”¨whileå¾ªç¯æ¯”é€’å½’ç‰ˆå¿«inline void kruskal(){ sort(edge+1,edge+m+1,cmp);//å°†è¾¹çš„æƒå€¼æ’åº for(int i=1;i&lt;=m;i++){ eu=findfather(edge[i].pointA), ev=findfather(edge[i].pointB); if(eu==ev) continue;//è‹¥å‡ºç°ç¯ï¼Œåˆ™continue ans+=edge[i].w;//æ›´æ–°ç­”æ¡ˆ father[ev]=eu; cnt++; if(cnt==n-1) break;//å¾ªç¯ç»“æŸæ¡ä»¶ }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) father[i]=i;//åˆå§‹åŒ–å¹¶æŸ¥é›† for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;edge[i].pointA,&amp;edge[i].pointB,&amp;edge[i].w); kruskal(); printf(\"%d\",ans); return 0;}","link":"/posts/57313/"},{"title":"æ ‘ä¸Šå·®åˆ†-é¢˜è§£","text":"éƒ½æ˜¯æ°´é¢˜å•¦ï¼Œä½ ä»¬éƒ½èƒ½ä¸€çœ¼ç§’çš„ EOJ Monthly 2018.8 D.Deliveryï¼ˆæ°´é¢˜ï¼‰é¢˜ç›®æè¿° æœ‰ä¸€æ£µ $N$ ä¸ªèŠ‚ç‚¹çš„æ ‘ ï¼Œæ ‘çš„æ¯æ¡è¾¹éƒ½æœ‰å„è‡ªçš„æƒå€¼ $W_i$ ï¼Œåœ¨è¯¢é—®å¼€å§‹å‰ï¼Œå¯ä»¥äº¤æ¢ä»»ä¸€ä¸¤æ¡è¾¹çš„æƒå€¼ï¼Œæ¬¡æ•°ä¸é™ï¼Œæœ‰ $q$ ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®åŒ…å«ä¸€ä¸ªèµ·ç‚¹ $S_i$ å’Œç»ˆç‚¹ $T_i$ ï¼Œä»èµ·ç‚¹åˆ°ç»ˆç‚¹ç»è¿‡çš„è¾¹çš„æƒå€¼å’Œå°±æ˜¯è¿™æ¬¡è¯¢é—®çš„èŠ±è´¹ï¼Œæ±‚æ‰€æœ‰è¯¢é—®çš„æœ€å°èŠ±è´¹å’Œ $$ 1 \\leq n \\leq 2 \\times 10^5,1 \\leq q \\leq 2 \\times 10^5 $$ $$ 1 \\leq u_i,v_i \\leq n,u_i \\neq v_i $$ $$ 1 \\leq w_i \\leq 1000 $$ $$ 1 \\leq s_i,t_i \\leq n,s_i \\neq t_i $$ é¢˜è§£è¿™å°±æ˜¯æ±‚è¾¹è¦†ç›–æ¬¡æ•°çš„è£¸é¢˜å•Šï¼Œè¦†ç›–è¾¹æŒ‰è¦†ç›–æ¬¡æ•°ç»™äºˆä»å°åˆ°å¤§çš„æƒå€¼å°±ç»“æŸå•¦ å¤ªæ°´ä¸è´´ä»£ç  BZOJ4424/CF19E Fairyï¼ˆå¤§æ°´é¢˜ï¼‰é¢˜ç›®æè¿° ç»™å®š $N$ ä¸ªç‚¹ï¼Œ$M$ æ¡è¾¹çš„æ— å‘å›¾ï¼Œå¯ä»¥ä»å›¾ä¸­åˆ é™¤ä¸€æ¡è¾¹ï¼Œé—®åˆ é™¤å“ªäº›è¾¹å¯ä»¥ä½¿å›¾å˜æˆä¸€ä¸ªäºŒåˆ†å›¾ã€‚ $$ 1 \\leq n,m \\leq 1000000 $$ é¢˜è§£é¦–å…ˆäºŒåˆ†å›¾æ˜¯æ²¡æœ‰å¥‡ç¯çš„ï¼Œæˆ‘ä»¬è¦åˆ è¾¹æ¥å»æ‰å¥‡ç¯ åªæœ‰ä¸€æ¡è¾¹è¢«æ‰€æœ‰çš„å¥‡ç¯è¦†ç›–æ—¶æ‰èƒ½å»åˆ å®ƒï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æ²¡æœ‰å¥‡ç¯ å¦‚æœè¿™æ¡è¾¹è¢«å¶ç¯è¦†ç›–çš„è¯ï¼Œæ— è®ºæ€ä¹ˆåˆ éƒ½ä¼šå‡ºç°ä¸€ä¸ªæ–°å¥‡ç¯ï¼Œè¿™æ¡è¾¹æ˜¯ä¸èƒ½åˆ çš„ æˆ‘ä»¬å¯¹å›¾ $dfs$ éå†ï¼Œå¯¹è¾¹æ–°å»ºå‡ºä¸€æ£µæ ‘ ç„¶åè¿™ä¸ªè¾¹çš„è¦†ç›–é—®é¢˜å°±å¯ä»¥é€šè¿‡æ ‘ä¸Šå·®åˆ†è§£å†³ $code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485struct data{ int nxt,to,id;}edge[N&lt;&lt;1];struct EDGEE{ int nxt,to;}edge2[N&lt;&lt;1]; int n,m,tot=0,tot2=0,top=0,cnt=0,cnt2=0;int head[N],head2[N],sta[N&lt;&lt;1],pos[N&lt;&lt;1],vis[N&lt;&lt;1],vis2[N&lt;&lt;1],sum[N&lt;&lt;1],fir[N&lt;&lt;1],ans[N];inline void add(int x,int y,int i){ edge[++tot].nxt=head[x]; edge[tot].to=y; edge[tot].id=i; head[x]=tot;}inline void add2(int x,int y){ edge2[++tot2].nxt=head2[x]; edge2[tot2].to=y; head2[x]=tot2;}void dfs(int now,int fa,int pre_id){ sta[++top]=now;pos[now]=top;vis[now]=1; for(int i=head[now];i;i=edge[i].nxt) { int tt=edge[i].to,nid=edge[i].id; if(nid==pre_id) continue; if(!vis2[nid]) vis2[nid]=1,add2(pre_id,nid),add2(nid,pre_id); if(!pos[tt]) fir[tt]=nid,dfs(tt,now,nid); else if(vis[tt]) { if((pos[now]-pos[tt]+1)&amp;1) sum[nid]++,sum[fir[tt]]--,cnt++; else sum[nid]--,sum[fir[tt]]++; } } vis[now]=0;top--;} void dfs2(int now,int fa){ for(int i=head2[now];i;i=edge2[i].nxt) { int tt=edge2[i].to; if(tt==fa) continue; dfs2(tt,now); sum[now]+=sum[tt]; } if(sum[now]==cnt) ans[++cnt2]=now;}int x,y;int main(){ #ifdef ROY1994 freopen(\"testdata.in\",\"r\",stdin); freopen(\"A.out\",\"w\",stdout); #endif io&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) { io&gt;&gt;x&gt;&gt;y; add(x,y,i); add(y,x,i); } for(int i=1;i&lt;=n;i++) if(!pos[i]) dfs(i,0,0); dfs2(0,0); if(!cnt) { io&lt;&lt;m&lt;&lt;'\\n'; for(int i=1;i&lt;=m;i++) io&lt;&lt;i&lt;&lt;' '; io&lt;&lt;'\\n'; return 0; } sort(ans+1,ans+cnt2+1); io&lt;&lt;cnt2&lt;&lt;'\\n'; for(int i=1;i&lt;=cnt2;i++) io&lt;&lt;ans[i]&lt;&lt;' '; io&lt;&lt;'\\n'; return 0;} 2017 SEERC L. Divide and Conquerï¼ˆå·¨æ°´é¢˜ï¼‰é¢˜ç›®æè¿° æœ‰ä¸€ä¸ªæœ‰ $N$ ä¸ªç‚¹çš„ç”±ä¸¤æ£µä¸åŒçš„æ ‘æ„æˆçš„å¤åˆå›¾(æ— é‡è¾¹)ã€‚ é—®æœ€å°‘åˆ‡æ–­å‡ æ¡è¾¹ï¼Œå¯ä»¥ä½¿åŸå›¾ä¸è”é€šã€‚å¹¶è¾“å‡ºæ–¹æ¡ˆæ•° $$ 1 \\leq n \\leq 1000000 $$ é¢˜è§£é¦–å…ˆåˆ‡æ–­çš„è¾¹æ•°è‚¯å®šæ˜¯ 2 ~ 3 è¿™æ˜¯ä¸¤æ£µæ ‘ç»„æˆçš„å›¾ï¼Œæ‰€ä»¥åªæœ‰ $2N-2$ æ¡è¾¹ï¼Œ å‡è®¾åˆ‡æ–­ 4 æ¡è¾¹æ‰èƒ½ä¿è¯ä¸è”é€šï¼Œé‚£ä¹ˆè‡³å°‘è¦æœ‰ $2N$ æ¡è¾¹ï¼Œå¾ˆæ˜¾ç„¶çŸ›ç›¾ æ‰€ä»¥è‚¯å®šåˆ‡æ–­ 2 ~ 3 æ¡è¾¹ é‚£ä¹ˆå¿…ç„¶æ˜¯ä¸€é¢—æ ‘ä¸Šåˆ‡æ–­ 1 æ¡è¾¹ï¼Œå¦ä¸€é¢—æ ‘ä¸Šåˆ‡æ–­ 1 ~ 2 æ¡è¾¹ æˆ‘ä»¬å…ˆä»¥ $A$ æ ‘ä¸ºä¸»ï¼ŒæŠŠ $B$ æ ‘çš„è¾¹ä½œä¸ºè¿”ç¥–è¾¹/æ¨ªæ’è¾¹ é‚£ä¹ˆå°±ç›¸å½“äºæ±‚æ¨ªè·¨ $A$ æ ‘çš„å±äº $B$ æ ‘çš„è¾¹æ•°ï¼Œ è¿™ä¸ªå¯ä»¥é€šè¿‡æ ‘ä¸Šå·®åˆ†è§£å†³ æ¯ä¸ªèŠ‚ç‚¹çš„ $sum$ å°±æ˜¯æ¨ªè·¨å…¶çš„ $B$ æ ‘è¾¹æ•° æˆ‘ä»¬å¯¹ $sum+1$ å–æœ€å°å€¼ $minn$ å¹¶è®°å½•æ–¹æ¡ˆæ•° å¦‚æœ $minn=2$ ç›´æ¥è¾“å‡º å¦‚æœ $minn=3$ å› ä¸ºå¯ä»¥ $A$ æ ‘æ–­ 2 æ¡ï¼Œ $B$ æ ‘æ–­ 1 æ¡ æˆ‘ä»¬äº¤æ¢å†ç»Ÿè®¡ä¸€æ¬¡æ–¹æ¡ˆåŠ ä¸Šä¹‹å‰çš„å°±æ˜¯æ–¹æ¡ˆæ•° $code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;inline int read(){ int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')w=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;}const int N=100005;struct data{ int from,to;}A[N&lt;&lt;1],B[N&lt;&lt;1];struct EDGEE{ int nxt,to;}edge[N&lt;&lt;1];int tot=0,head[N];int f[N][30],dep[N],sum[N],q[N&lt;&lt;2];int n,stp,ans,minn=0x7fffffff;int m1,m2;inline void add(int x,int y){ edge[++tot].nxt=head[x]; edge[tot].to=y; head[x]=tot;}void bfs(){ int Head=1,tail=0; dep[1]=1;f[1][0]=0; q[++tail]=1; while(Head&lt;=tail) { int now=q[Head++]; for(int i=head[now];i;i=edge[i].nxt) { int tt=edge[i].to; if(dep[tt]) continue ; dep[tt]=dep[now]+1; f[tt][0]=now; for(int j=1;j&lt;=stp;j++) f[tt][j]=f[f[tt][j-1]][j-1]; q[++tail]=tt; } }}inline int lca(int x,int y){ if(dep[x]&lt;dep[y]) swap(x,y); for(int i=stp;i&gt;=0;i--) if(dep[f[x][i]]&gt;=dep[y]) x=f[x][i]; if(x==y) return x; for(int i=stp;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];}void dfs(int x){ for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==f[x][0]) continue; dfs(tt); sum[x]+=sum[tt]; } if(x==1) return ; if(sum[x]+1&lt;minn) minn=sum[x]+1,ans=1; else if(sum[x]+1==minn) ans++;}inline void ADD(int ff){ if(ff==1) for(int i=1;i&lt;n;i++) add(A[i].from,A[i].to),add(A[i].to,A[i].from); else for(int i=1;i&lt;n;i++) add(B[i].from,B[i].to),add(B[i].to,B[i].from); }inline void ClearE(){ memset(edge,0,sizeof(edge)); memset(head,0,sizeof(head)); memset(sum,0,sizeof(sum)); memset(dep,0,sizeof(dep)); memset(f,0,sizeof(f)); tot=0;}int x,y;int main(){// freopen(\"ME.in\",\"r\",stdin);// freopen(\"ME.out\",\"w\",stdout); n=read(); stp=(int)log2(n)+1; for(int i=1;i&lt;n;i++) { x=read();y=read(); A[i].from=x,A[i].to=y; } for(int i=1;i&lt;n;i++) { x=read();y=read(); B[i].from=x,B[i].to=y; } ADD(1); bfs(); for(int i=1;i&lt;n;i++) { sum[B[i].from]++; sum[B[i].to]++; sum[lca(B[i].from,B[i].to)]-=2; } dfs(1); if(minn==2) { printf(\"%d %d\\n\",minn,ans); return 0; } ClearE(); ADD(2); bfs(); for(int i=1;i&lt;n;i++) { sum[A[i].from]++; sum[A[i].to]++; sum[lca(A[i].from,A[i].to)]-=2; } dfs(1); printf(\"%d %d\\n\",minn,ans); return 0;}","link":"/posts/2952530072/"},{"title":"æ ‘çš„ç›´å¾„-é¢˜è§£","text":"éƒ½æ˜¯æ°´é¢˜å•¦ï¼Œä½ ä»¬éƒ½èƒ½ä¸€çœ¼ç§’çš„ BZOJ1999 [Noip2007] Coreæ ‘ç½‘çš„æ ¸é¢˜ç›®æè¿° ç»™å®šä¸€æ£µå¸¦è¾¹æƒæ— æ ¹æ ‘ï¼Œåœ¨å…¶ç›´å¾„ä¸Šæ±‚å‡ºä¸€æ®µé•¿åº¦ä¸è¶…è¿‡ $s$ çš„è·¯å¾„ $F$ ï¼Œä½¿å¾—ç¦»è·¯å¾„è·ç¦»æœ€è¿œçš„ç‚¹åˆ°è·¯å¾„çš„è·ç¦» $ECC$ æœ€çŸ­ã€‚ ç‚¹ $v$ åˆ°è·¯å¾„ $F$ è·ç¦» $D(v,ğ¹)$ $=$ $minâ¡$ { $d(v,u)$ } , $u$ ä¸ºè·¯å¾„ä¸Šçš„ç‚¹ $$ n \\leq 500000,s &lt; 2^{32} ï¼Œæ‰€æœ‰è¾¹æƒ&lt;500 $$ é¢˜è§£å¯¹è·ç¦» $ECC$ äº§ç”Ÿè´¡çŒ®çš„ç‚¹æ¥è‡ªä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ† ç›´å¾„çš„ç«¯ç‚¹ è·¯å¾„ä¸Šçš„ç‚¹åˆ°éç›´å¾„ä¸Šç‚¹çš„è·ç¦» å¯¹äºç›´å¾„çš„ç«¯ç‚¹ï¼Œæˆ‘ä»¬æœ‰ä¸ªç»“è®ºï¼Œç¦»ä¸€ä¸ªç‚¹è·ç¦»æœ€è¿œçš„ç‚¹æ˜¯ç›´å¾„çš„ä¸€ä¸ªç«¯ç‚¹ å› è€Œæˆ‘ä»¬æ— éœ€è€ƒè™‘ç›´å¾„ä¸Šé™¤ç«¯ç‚¹å¤–çš„å…¶å®ƒç‚¹ï¼Œ é‚£ä¹ˆè·¯å¾„ $F$ å°½å¯èƒ½å¤§ï¼Œæ‰èƒ½ä¿è¯è¿™éƒ¨åˆ†è´¡çŒ®å°½å¯èƒ½å° ä½†è¿™åªæ˜¯ä¸€ä¸ªéƒ¨åˆ†ï¼Œæˆ‘ä»¬è¿˜è¦è€ƒè™‘è·¯å¾„ä¸Šçš„ç‚¹åˆ°éç›´å¾„ä¸Šç‚¹çš„è·ç¦»çš„è´¡çŒ® è¿™éƒ¨åˆ†è´¡çŒ®å¯èƒ½ä¼šæ›´å¤§ï¼Œä½¿å®é™…ä¸Šçš„è·ç¦» $ECC$ æ¯”ç›´å¾„çš„ç«¯ç‚¹å½±å“é€ æˆçš„ $ECC$ å¤§ï¼Œ ä»¥è‡³äºæ©ç›–ä½ç›´å¾„çš„ç«¯ç‚¹çš„è´¡çŒ®ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å– $max$ ä¿è¯ç¬¦åˆå®šä¹‰ æ±‚è¿™éƒ¨åˆ†è´¡çŒ®å¯ä»¥å¯¹è·¯å¾„ä¸Šæ¯ä¸ªç‚¹ $dfs$ è§£å†³ å› ä¸ºåœ¨ç›´å¾„ä¸Šä¸”åœ¨è·¯å¾„å¤–çš„ç‚¹åˆ°éç›´å¾„ç‚¹çš„è·ç¦»ä¸€å®šå°äºç­‰äºç›´å¾„çš„ç«¯ç‚¹çš„è´¡çŒ® æ²¡æœ‰å½±å“ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬å¯¹æ•´ä¸ªç›´å¾„ä¸Šçš„çš„ç‚¹ $dfs$ï¼Œ $code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define min(a,b) ((a)&lt;(b))?(a):(b)#define max(a,b) ((a)&gt;(b))?(a):(b)#define INF 0x7fffffffusing namespace std;inline void read(int &amp;x){ x=0;char ch;int f=1;ch=getchar(); for(;!isdigit(ch);) {if(ch=='-') f=-1;ch=getchar();} for(;isdigit(ch);) x=x*10+(ch^48),ch=getchar(); x*=f;}const int N=500005;struct EDGEE{ int nxt,wei,to;}edge[N&lt;&lt;1];int head[N],tot;inline void add(int x,int y,int v){ edge[++tot].nxt=head[x]; edge[tot].to=y; edge[tot].wei=v; head[x]=tot;}int n,s,maxn,maxp,ls;int dep[N],is_d[N],pre[N];void dfs(int x,int fa){ pre[x]=fa; if(dep[x]&gt;maxn) { maxp=x; maxn=dep[x]; } for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa||is_d[tt]) continue; dep[tt]=dep[x]+edge[i].wei; dfs(tt,x); }}int x,y,w,ans=INF;int main(){ read(n);read(s); for(int i=1;i&lt;n;i++) { read(x);read(y);read(w); add(x,y,w);add(y,x,w); } maxn=-INF; dep[1]=0; dfs(1,0); ls=maxp; maxn=-INF; dep[ls]=0; dfs(ls,0); for(int i=maxp,j=maxp;i;i=pre[i]) { while(dep[j]-dep[i]&gt;s) j=pre[j]; ans=min(ans,max(dep[i],maxn-dep[j])); } for(int i=maxp;i;i=pre[i]) is_d[i]=1; for(int i=maxp;i;i=pre[i]) { dep[i]=0; dfs(i,pre[i]); } for(int i=1;i&lt;=n;i++) ans=max(ans,dep[i]); printf(\"%d\",ans); } UVA11695 Flight Planningé¢˜ç›®æè¿° ç»™ä¸€ä¸ª $N$ ä¸ªèŠ‚ç‚¹è¾¹æƒä¸º 1 çš„æ— æ ¹æ ‘ï¼Œå»æ‰ä¸€æ¡è¾¹ï¼Œæ–°å¢ä¸€æ¡è¾¹ï¼Œæ±‚æ–°çš„æ ‘çš„æœ€é•¿é“¾ï¼Œé—®æ€ä¹ˆå»è¾¹å’ŒåŠ è¾¹ï¼Œä½¿å¾—æœ€é•¿é“¾çš„é•¿åº¦æœ€å° $$ 1 \\leq n \\leq 2500 $$ é¢˜è§£æˆ‘ä»¬å¯ä»¥æšä¸¾æ¯ä¸€æ¡è¦åˆ å»çš„è¾¹ å»æ‰è¿™æ¡è¾¹åï¼Œæœ€å°çš„æ ‘çš„ç›´å¾„ä¼šå‡ºç°åœ¨ä»¥ä¸‹å‡ ç§æƒ…å†µä¸­ å­æ ‘ $A$ çš„ç›´å¾„ å­æ ‘ $B$ çš„ç›´å¾„ åŠ è¾¹åæ ‘çš„ç›´å¾„ å­æ ‘ $A$ ï¼Œ$B$ çš„ç›´å¾„æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¿è¯åŠ è¾¹åæ ‘çš„ç›´å¾„æœ€å° æ‰€ä»¥è¦åœ¨å­æ ‘ä¸­æ‰¾åˆ°ä¸€ä¸ªç‚¹ä½¿å…¶åˆ°è¯¥å­æ ‘å…¶ä»–ç‚¹çš„æœ€å¤§è·ç¦»æœ€å° å¾ˆæ˜¾ç„¶ï¼Œè¿™ä¸ªç‚¹ä¸€å®šæ˜¯ç›´å¾„çš„ä¸­ç‚¹ï¼Œ å­æ ‘çš„è¿™ä¸¤ä¸ªç‚¹å°±æ˜¯è¦è¿è¾¹çš„èŠ‚ç‚¹ $code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#define INF 0x7fffffffusing namespace std;inline void read(int &amp;x){ x=0;char ch;int f=1;ch=getchar(); for(;!isdigit(ch);) {if(ch=='-') f=-1;ch=getchar();} for(;isdigit(ch);) x=x*10+(ch^48),ch=getchar(); x*=f;}const int N=5005;struct EDGEE{ int nxt,from,to;}edge[N&lt;&lt;1];int head[N],tot;int T,n,x,y,addA,addB,p_addA,p_addB,lenA,lenB,delA,delB,ans=INF;int dep[N],pre[N],maxp,maxn=-INF,minn=INF,rbq,ls;inline void add(int x,int y){ edge[++tot].nxt=head[x]; edge[tot].from=x; edge[tot].to=y; head[x]=tot;}void dfs(int x,int fa,const int &amp;del){ pre[x]=fa; if(dep[x]&gt;maxn) { maxp=x; maxn=dep[x]; } for(int i=head[x];i;i=edge[i].nxt) { if(i==del||i==(del+1)) continue; int tt=edge[i].to; if(tt==fa) continue; dep[tt]=dep[x]+1; dfs(tt,x,del); }}void solve(int del){// memset(pre,0,sizeof(pre)); maxp=edge[del].from; maxn=-INF; minn=INF; dep[edge[del].from]=0; dfs(edge[del].from,0,del);// memset(pre,0,sizeof(pre)); ls=maxp; maxn=-INF; minn=INF; dep[ls]=0; dfs(ls,0,del); lenA=maxn; p_addA=maxp; for(int i=0;i&lt;lenA/2;i++) p_addA=pre[p_addA]; //--------------------------------------------------// memset(pre,0,sizeof(pre)); maxp=edge[del].to; maxn=-INF; minn=INF; dep[edge[del].to]=0; dfs(edge[del].to,0,del);// memset(pre,0,sizeof(pre)); ls=maxp; maxn=-INF; minn=INF; dep[ls]=0; dfs(ls,0,del); lenB=maxn; p_addB=maxp; for(int i=0;i&lt;lenB/2;i++) p_addB=pre[p_addB]; rbq=max(max(lenA,lenB),(lenA+1)/2+(lenB+1)/2+1);// cout&lt;&lt;\"$\"&lt;&lt;lenA&lt;&lt;' '&lt;&lt;lenB&lt;&lt;\"$\"&lt;&lt;endl; if(ans&gt;rbq) { ans=rbq; delA=edge[del].from; delB=edge[del].to; addA=p_addA; addB=p_addB; }}int main(){ read(T); for(;T--;) { memset(head,0,sizeof(head)); memset(edge,0,sizeof(edge)); tot=0;ans=INF; read(n); for(int i=1;i&lt;n;i++) { read(x);read(y); add(x,y);add(y,x); } for(int i=1;i&lt;=tot;i+=2) { solve(i); } printf(\"%d\\n\",ans); printf(\"%d %d\\n\",delA,delB); printf(\"%d %d\\n\",addA,addB); } return 0;} BZOJ1912 [APIO2010] patrol å·¡é€»é¢˜ç›®æè¿°é“¾æ¥ é¢˜è§£å¾ˆæ˜¾ç„¶ï¼Œå½“ $k = 1$ æ—¶ï¼Œæ‰¾åˆ°ç›´å¾„ç„¶åè¿ç«¯ç‚¹å°±å¯ä»¥äº† å½“ $k = 2$ æ—¶ï¼Œæˆ‘ä»¬è¦æ‰¾ç›´å¾„å’Œè¾¹ä¸ç›¸äº¤çš„ç¬¬äºŒå¤§ç›´å¾„ å½“ä¸¤æ¡ç›´å¾„ç›¸äº¤çš„æ—¶å€™ï¼Œ å› ä¸ºåŠ çš„è¾¹å¿…é¡»èµ°ï¼Œæ‰€ä»¥ç¬¬äºŒæ¡åŠ è¾¹å¹¶æ²¡æœ‰èµ·åˆ°ç¼©çŸ­è·¯ç¨‹çš„ä½œç”¨ï¼Œåè€Œå¤šèŠ±è´¹äº† $1$ åè€Œä¸å¦‚æŠŠè¾¹é€€åŒ–æˆç‚¹ï¼Œé•¿åº¦ä¸º $0$ æ‰¾æ¬¡å¤§ç›´å¾„å¯ä»¥æŠŠç›´å¾„ä¸Šçš„è¾¹æƒæ”¹æˆ $-1$ ï¼Œå†æ±‚ç›´å¾„ ç”±äºå‡ºç°äº†è´Ÿè¾¹æƒï¼Œç”¨ dfs/bfs ä¼šæŒ‚ ï¼ˆå¯èƒ½æ˜¯æˆ‘å¤ªèœäº†ï¼‰ æ‰€ä»¥ç”¨ $dp$ æ±‚è§£ $code$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define INF 0x7fffffffusing namespace std;inline void read(int &amp;x){ x=0;char ch;int f=1;ch=getchar(); for(;!isdigit(ch);) {if(ch=='-') f=-1;ch=getchar();} for(;isdigit(ch);) x=x*10+(ch^48),ch=getchar(); x*=f;}const int N=100005;struct EDGEE{ int nxt,wei,to;}edge[N&lt;&lt;1];int head[N],tot;int n,k,maxn=-INF,maxp,ls,len1,len2; int dep[N],pre[N],dis[N];inline void add(int x,int y){ edge[++tot].nxt=head[x]; edge[tot].to=y; edge[tot].wei=1; head[x]=tot;}void dfs(int x,int fa){ pre[x]=fa; if(maxn&lt;dep[x]) { maxn=dep[x]; maxp=x; } for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa) continue;// cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl; dep[tt]=dep[x]+edge[i].wei; dfs(tt,x); } }void maxlen(int x,int fa){ for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa) continue; maxlen(tt,x);// cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl; len2=max(len2,dis[x]+dis[tt]+edge[i].wei); dis[x]=max(dis[x],dis[tt]+edge[i].wei); }}void work(int x,int fa){ for(int i=head[x];i;i=edge[i].nxt) { int tt=edge[i].to; if(tt==fa||tt!=pre[x]) continue;// cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl; edge[i].wei=-1; edge[i&amp;1?(i+1):(i-1)].wei=-1; work(tt,x); }}int x,y;int main(){ read(n);read(k); for(int i=1;i&lt;n;i++) { read(x);read(y); add(x,y);add(y,x); } maxn=-INF; dep[1]=0; dfs(1,0); ls=maxp; maxn=-INF; dep[ls]=0; dfs(ls,0); len1=maxn; if(k==1) { printf(\"%d\",2*(n-1)-len1+1); return 0; } work(maxp,0); maxlen(1,0); printf(\"%d\",2*(n-1)-len1-len2+2);}","link":"/posts/1138517949/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","link":"/tags/æ•°æ®ç»“æ„/"},{"name":"æ¨¡ç‰ˆ","slug":"æ¨¡ç‰ˆ","link":"/tags/æ¨¡ç‰ˆ/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","link":"/tags/çº¿æ®µæ ‘/"},{"name":"ZKW","slug":"ZKW","link":"/tags/ZKW/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"GAN","slug":"GAN","link":"/tags/GAN/"},{"name":"å¹³è¡¡æ ‘","slug":"å¹³è¡¡æ ‘","link":"/tags/å¹³è¡¡æ ‘/"},{"name":"FHQ","slug":"FHQ","link":"/tags/FHQ/"},{"name":"è‹±è¯­","slug":"è‹±è¯­","link":"/tags/è‹±è¯­/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"åˆ†å—","slug":"åˆ†å—","link":"/tags/åˆ†å—/"},{"name":"æš´åŠ›","slug":"æš´åŠ›","link":"/tags/æš´åŠ›/"},{"name":"æ•°è®º","slug":"æ•°è®º","link":"/tags/æ•°è®º/"},{"name":"æœ€å°ç”Ÿæˆæ ‘","slug":"æœ€å°ç”Ÿæˆæ ‘","link":"/tags/æœ€å°ç”Ÿæˆæ ‘/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","link":"/tags/é¢˜è§£/"},{"name":"ç»éªŒ","slug":"ç»éªŒ","link":"/tags/ç»éªŒ/"}],"categories":[]}